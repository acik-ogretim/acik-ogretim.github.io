[
  {
    "id": "3623918",
    "unitNumber": 1,
    "text": "Veri yapısı kullanmadaki amaç nedir?",
    "correctAnswer": "C",
    "options": {
      "A": "Aynı görevlerin işlem adımlarını basitleştirmektir.",
      "B": "Farklı görevlerin zaman karmaşıklığını arttırmaktır.",
      "C": "Farklı görevlerin uzay ve zaman karmaşıklığını azaltmaktır.",
      "D": "Aynı görevlerin bellekte kapladığı alanı oranlamaktır.",
      "E": "Farklı görevlerin yalnızca görünürlüğünü arttırmaktır."
    },
    "explanation": "Veri yapılarının kullanılmasındaki temel amaç, bilgisayarda yaptığımız farklı işlemleri hem daha hızlı hem de daha az bellek kullanarak gerçekleştirmektir. Örneğin bir veriyi ararken ya da silerken kullandığımız yapı doğru seçilirse işlem süresi çok kısalabilir. Kitapta da açıkça belirtildiği gibi, veri yapıları <strong>farklı görevlerin uzay (bellek) ve zaman (işlem süresi) karmaşıklığını azaltmak için</strong> vardır. Bu nedenle doğru cevap C<strong> şıkkıdır</strong>; diğer şıklar ya eksik ya da yanlış bilgi içermektedir."
  },
  {
    "id": "3623919",
    "unitNumber": 1,
    "text": "Aşağıdakierden hangisi \"Veri türü\" kavramını en doğru şekilde tanımlar?",
    "correctAnswer": "A",
    "options": {
      "A": "Derleyiciye veya yorumlayıcıya programcının verileri nasıl kullanmayı planladığını söyleyen bir veri sınıflandırmasıdır.",
      "B": "Derleyiciye veya yorumlayıcıya sayıları nasıl kullanmayı planladığını söyleyen bir sentezdir.",
      "C": "Programcının verileri nasıl kullanmayı planladığını analiz eden bir veri sınıflandırmasıdır.",
      "D": "Derleyiciye veya yorumlayıcıya asal verileri nasıl hesaplamayı söyleyen bir veri sınıflandırmasıdır.",
      "E": "Yorumlayıcıya programcının verileri nasıl hesaplaması gerektiğini söyleyen bir veri sınıflandırmasıdır."
    },
    "explanation": "Veri türü, derleyiciye veya yorumlayıcıya programcının verileri nasıl kullanmayı planladığını söyleyen bir veri sınıflandırmasıdır."
  },
  {
    "id": "3623920",
    "unitNumber": 1,
    "text": "\"Bir programla girdiler ve çıktılar şeklinde olan etkileşimler, birçok dilde ..... olarak ele alınmaktadır.\" Cümlesindeki boşluğa aşağıdaki seçeneklerden hangisi gelmelidir?",
    "correctAnswer": "A",
    "options": {
      "A": "bayt akışı",
      "B": "veri seti",
      "C": "sayısal veri",
      "D": "kayan noktalı sayı",
      "E": "değişken"
    },
    "explanation": "Bir programla girdiler ve çıktılar şeklinde olan etkileşimler, birçok dilde bir bayt akışı olarak ele alınmaktadır."
  },
  {
    "id": "3623922",
    "unitNumber": 1,
    "text": "Algoritma, adını kimden almıştır?",
    "correctAnswer": "E",
    "options": {
      "A": "el-Cezerî",
      "B": "İbn Huseyin",
      "C": "ibn-Erzen",
      "D": "el-Ahmed",
      "E": "el-Hârizmî"
    },
    "explanation": "Algoritma; adını 9.yy.’da yaşamış, Özbekistan’ın Harezm şehrinde doğmuş olan Ebu Abdullah Muhammed İbn Musa el-Hârizmî’den almıştır."
  },
  {
    "id": "3623923",
    "unitNumber": 1,
    "text": "Aşağıdaki seçeneklerden hangisi algoritma yazmak için ihtiyaç olan ön koşullardan biri <strong>değildir?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "Bu algoritma ile çözülecek problemin net tanımı yapılmalıdır.",
      "B": "Problem çözülürken problemin kısıtları göz önünde bulundurulmalıdır.",
      "C": "Sorunu çözmek için alınacak girdi belirlenmelidir.",
      "D": "Sorun çözülmeden çıktılar ortaya konmalıdır.",
      "E": "Problemin çözümü, verilen kısıtlamalar dahilinde olmalıdır."
    },
    "explanation": "Algoritma yazmak için ön koşul olarak aşağıdakilere ihtiyaç vardır:<br/>• Bu algoritma ile çözülecek problemin net tanımı yapılmalıdır.<br/>• Problem çözülürken problemin kısıtları göz önünde bulundurulmalıdır.<br/>• Sorunu çözmek için alınacak girdi belirlenmelidir.<br/>• Sorun çözüldüğünde beklenen çıktı belirlenmelidir.<br/>• Problemin çözümü, verilen kısıtlamalar dahilinde olmalıdır."
  },
  {
    "id": "3623924",
    "unitNumber": 1,
    "text": "Big-O notasyonu, ne için kullanılır?",
    "correctAnswer": "B",
    "options": {
      "A": "Bir algoritmanın yönünü veya zaman akışını (time line) hesaplamak",
      "B": "Bir algoritmanın performansını veya zaman karmaşıklığını (time complexity) hesaplamak için.",
      "C": "Zaman kavramını (time concept) hesaplamak için.",
      "D": "Algoritmanın performans yönünü (performance aspect) hesaplamak için.",
      "E": "Notasyonun performans kapasitesini (performance capacity) hesaplamak için."
    },
    "explanation": "Big-O notasyonu, bir algoritmanın performansını veya zaman karmaşıklığını (time complexity) hesaplamak için kullanılır."
  },
  {
    "id": "3623925",
    "unitNumber": 1,
    "text": "Bir algoritmanın büyük girdiler karşısındaki davranışını inceleyen matematiksel yönteme ne ad verilmektedir?",
    "correctAnswer": "C",
    "options": {
      "A": "Sabit analiz",
      "B": "Algoritma",
      "C": "Asimptotik analiz",
      "D": "Doğrusal analiz",
      "E": "Ayırıcı analiz"
    },
    "explanation": "Bir algoritmanın büyük girdiler karşısındaki davranışını inceleyen matematiksel yönteme Asimptotik analiz adı verilmektedir."
  },
  {
    "id": "3623926",
    "unitNumber": 1,
    "text": "\"........., en kötü durum için bir Asimptotik Gösterim veya belirli bir işlev için büyüme tavanı olarak tanımlanabilir.\" Cümlesindeki boşluğa aşağıdaki seçeneklerden hangisi gelmelidir?",
    "correctAnswer": "B",
    "options": {
      "A": "Genellikle S olarak yazılan Big-S",
      "B": "Genellikle O olarak yazılan Big-O",
      "C": "Genellikle C olarak yazılan Big-C",
      "D": "Genellikle K olarak yazılan Big-K",
      "E": "Genellikle L olarak yazılan Big-L"
    },
    "explanation": "Genellikle O olarak yazılan Big-O, en kötü durum için bir Asimptotik Gösterim veya belirli bir işlev için büyüme tavanı olarak tanımlanabilir."
  },
  {
    "id": "3623927",
    "unitNumber": 1,
    "text": "Veri yapısı ile ilgili aşağıdaki bilgilerden hangisi hatalıdır?",
    "correctAnswer": "E",
    "options": {
      "A": "Veri yapısı, bir bilgisayardaki verileri etkin bir şekilde kullanılabilecek şekilde düzenlemenin özel bir yoludur.",
      "B": "Veri yapıları, verilerin bilgisayar ortamında yönetilmesi ve depolanmasını sağlayan veri nesneleri koleksiyonu olarak tanımlanabilir.",
      "C": "Veri yapısı kullanmadaki amaç, farklı görevlerin uzay ve zaman karmaşıklığını azaltmaktır.",
      "D": "İyi bir veri yapısı seçimi, çeşitli kritik işlemleri verimli bir şekilde gerçekleştirmeyi mümkün kılar.",
      "E": "Verimli bir veri yapısı, yapıyı işlemek için maksimum bellek alanı ve yürütme süresi kullanır."
    },
    "explanation": "Veri yapısı bilgisayardaki dijital verileri depolamanın ve bu veriler üzerinde farklı eylemleri gerçekleştirmenin en kolay yolunu sağlayan bir veri ögeleri grubudur. Veri yapısı, bir bilgisayardaki verileri etkin bir şekilde kullanılabilecek şekilde düzenlemenin özel bir yoludur. Veri yapıları, verilerin bilgisayar ortamında yönetilmesi ve depolanmasını sağlayan veri nesneleri koleksiyonu olarak tanımlanabilir. Çeşitli veri yapıları türleri olarak: ağaç (tree) yapıları, yığınlar (stack), diziler (array), kuyruklar (queues), listeler vb. örnek gösterilebilir. Veri yapısı kullanmadaki amaç, farklı görevlerin uzay ve zaman karmaşıklığını azaltmaktır. İyi bir veri yapısı seçimi, çeşitli kritik işlemleri verimli bir şekilde gerçekleştirmeyi mümkün kılar. Verimli bir veri yapısı, yapıyı işlemek için minimum bellek alanı ve yürütme süresi kullanır. Geliştirilen hemen hemen her program veya yazılım sisteminde kullanılan farklı temel ve gelişmiş veri yapıları bulunmaktadır. Bu yüzden verimli çalışan bir program haz"
  },
  {
    "id": "3623928",
    "unitNumber": 1,
    "text": "Algoritma tarafından tüketilen bellek miktarına ne ad verilir?",
    "correctAnswer": "B",
    "options": {
      "A": "Bellek karmaşıklığı",
      "B": "Uzay/Alan karmaşıklığı",
      "C": "Doğrusal zaman karmaşıklığı",
      "D": "Karekök zaman karmaşıklığı",
      "E": "Kübik zaman karmaşıklığı"
    },
    "explanation": "Zaman karmaşıklığı, algoritma tarafından her bir talimat setini yürütmek için geçen zamandır. Basit bir problemin farklı yöntemlerle çözülebileceği durumlarda en verimli algoritmayı seçmenin her zaman daha iyi sonuç vereceği unutulmamalıdır.<br/>Uzay/Alan karmaşıklığı genellikle algoritma tarafından tüketilen bellek miktarı olarak adlandırılır. Yardımcı alan ve girdi alanı olmak üzere iki farklı alandan oluşmaktadır."
  },
  {
    "id": "3623929",
    "unitNumber": 1,
    "text": "Ücret verisi için hangi veri tipi kullanılmalıdır?",
    "correctAnswer": "A",
    "options": {
      "A": "float",
      "B": "int",
      "C": "byte",
      "D": "string",
      "E": "char"
    },
    "explanation": "<img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/f4e96a659a941d1eab9730ad8051f093.png\" alt=\"\" width=\"722\" height=\"655\"><br/>Ücret verisinde TL ve kuruş gibi kesirli sayılarla belirtilebilen bir gerçek sayı (float, double) kullanılır."
  },
  {
    "id": "3623930",
    "unitNumber": 1,
    "text": "Veri türü ve veri yapısı karşılaştırmalarından hangisi doğrudur?",
    "correctAnswer": "E",
    "options": {
      "A": "Veri yapısı, bir değerin atanabileceği bir değişkenin biçimidir.",
      "B": "Veri yapısı değer tutabilir ancak veri tutamaz.",
      "C": "Veri türlerinde zaman karmaşıklığı önemli bir rol oynar.",
      "D": "Veri yapılarında yalnızca depolanabilecek veri türü temsil edildiği için verilerin değeri saklanmaz.",
      "E": "Veri yapısı yığın, kuyruk, ağaç vb. örnek verilebilir."
    },
    "explanation": "Tablo 1.2'ye göre A, B, C ve D seçeneklerindeki bilgiler sırasıyla veri türü, veri türü, veri yapısı ve veri türüne aittir. Sadece E seçeneğindeki bilgi doğrudur.<br/><img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/7b869d7d89d24f8d7214255907016b26.png\" alt=\"\" width=\"805\" height=\"419\">"
  },
  {
    "id": "3623931",
    "unitNumber": 1,
    "text": "Aşağıdakilerden hangisi doğrusal olmayan veri yapılarına örnektir?",
    "correctAnswer": "B",
    "options": {
      "A": "Kuyruk",
      "B": "Ağaç",
      "C": "Yığın",
      "D": "Linkli Liste",
      "E": "Dizi"
    },
    "explanation": "<img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/e79f7c775b55f06ae0dcb65875deba11.png\" alt=\"\" width=\"753\" height=\"419\"><br/><strong>Doğrusal (Linear) veri yapısı:</strong> Veri ögelerinin sıralı veya doğrusal olarak düzenlendiği, her ögenin önceki ve sonraki bitişik ögelere eklendiği veri yapısına doğrusal veri yapısı denir. Doğrusal veri yapılarına örnek olarak dizi, yığın, sıra, bağlantılı liste vb. verilebilir.<br/><strong>Statik veri yapısı:</strong> Statik veri yapısı sabit bir hafıza boyutuna sahiptir. Statik bir veri yapısındaki ögelere erişmek daha kolaydır. Diziler, bu veri yapısına örnek olarak verilebilir.<br/><strong>Dinamik veri yapısı:</strong> Dinamik veri yapısında boyut sabit değildir. Kodun çalışma zamanı sırasında, bellek (alan) karmaşıklığı ile ilgili olarak verimli kabul edilebileceği anda rastgele güncellenebilir. Kuyruk, yığın vb. bu veri yapısının örnekleri olarak verilebilir.<br/><strong>Doğrusal olmayan veri yapısı:</strong> Veri ögelerinin sıralı veya doğrusal olarak yerleştirilmediği veri yapılarına doğrusal olmayan veri yapıları denir. Doğrusal olmayan bir veri yapısında, tüm ögeleri yalnızca tek bir döngüde göremeyiz. Bu veri yapısına örnek olarak ağaçlar ve grafikler verilebilir"
  },
  {
    "id": "3623932",
    "unitNumber": 1,
    "text": "Aşağıdakilerden hangisi bir algoritmanın \"sonluluk\" özelliğini betimler?",
    "correctAnswer": "C",
    "options": {
      "A": "Algoritma bir dizi girdiye uygulanır.",
      "B": "Algoritma çıktı üretir.",
      "C": "Sınırlı sayıda komut yürütüldükten sonra algoritma durmalıdır.",
      "D": "Adımlar kesin olarak belirtilmelidir.",
      "E": "Her adımın sonucu benzersiz bir şekilde tanımlanır"
    },
    "explanation": "Bir algoritmanın özelliklerinden \"sonluluk\" sınırlı sayıda komut yürütüldükten sonra algoritmanın durması olarak tanımlanır.<br/>Bir algoritmanın özellikleri:<br/>• Kesinlik - adımlar kesin olarak belirtilmelidir.<br/>• Benzersizlik - her adımın sonucu benzersiz bir şekilde tanımlanır ve yalnızca önceki adımların girdisine ve sonucuna bağlıdır.<br/>• Sonluluk - sınırlı sayıda komut yürütüldükten sonra algoritma durmalıdır.<br/>• Girdi - algoritma girdi alır.<br/>• Çıktı - algoritma çıktı üretir.<br/>• Genellik, Uygulanabilirlik - algoritma bir dizi girdiye uygulanır."
  },
  {
    "id": "3623933",
    "unitNumber": 1,
    "text": "<img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/8fc5ddaaaa84e32bf0cb09ed7046531f.png\" alt=\"\" width=\"72\" height=\"40\"> şeklinin akış şemasındaki anlamı aşağıdakilerden hangisidir?",
    "correctAnswer": "D",
    "options": {
      "A": "Başla / Bitir",
      "B": "Bağlantı",
      "C": "Karşılaştırma ve Karar",
      "D": "Döngü",
      "E": "Ekran Çıktısı"
    },
    "explanation": "<img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/463fb8aae4a621959f772e247d6ce84f.png\" alt=\"\" width=\"548\" height=\"639\"><br/>Akış şemalarındaki şekiller, algoritmanın en net ve anlaşılır şekilde gösterimi için kullanılmaktadır. Akışta kullanılan şekillerin içlerine; algoritmadaki gibi uzun atamalar, karşılaştırma ve uzun değişken isimleri yazılması tavsiye edilmez. Şekiller anlamayı zorlaştırmayacak bir biçimde kullanılmalıdır. Tablo 1.3'e göre soru kökünde verilen şekil akış şemalarında döngü anlamını taşır."
  },
  {
    "id": "3623934",
    "unitNumber": 1,
    "text": "Kabarcıkla sıralama (bubble sort), seçimle sıralama (selection sort) ve araya girerek sıralama (insertion sort) gibi genel olarak kullanılan bir sıralama algoritması için çalışma zamanı nasıl hesaplanır?",
    "correctAnswer": "A",
    "options": {
      "A": "O(N²) - Kuadratik Zaman Karmaşıklığı",
      "B": "O(sqrt(N)) - Karekök Zaman Karmaşıklığı",
      "C": "O(N³) - Kübik Zaman Karmaşıklığı",
      "D": "O(N^c) - Polinom Zaman Karmaşıklığı",
      "E": "O(c^N) - Üstel Zaman Karmaşıklığı"
    },
    "explanation": "Kod 1.8<br/>for( int i = 0; i &lt; n; i++)<br/>for( int j = 0; j &lt; n; j++)<br/>sayac++;<br/>Algoritmanın çalışma süresi, N kez doğrusal bir işlem gerçekleştirmenin bir sonucudur yani N ile N çarpımı olarak hesaplanır. Kabarcıkla sıralama (bubble sort), seçimle sıralama (selection sort) ve araya girerek sıralama (insertion sort) gibi genel olarak kullanılan bir sıralama algoritması O(N²) alır."
  },
  {
    "id": "3623935",
    "unitNumber": 1,
    "text": "Bir algoritmanın büyük girdiler karşısındaki davranışını inceleyen matematiksel yönteme ne ad verilir?",
    "correctAnswer": "A",
    "options": {
      "A": "Asimptotik analiz",
      "B": "Akış şeması",
      "C": "Algoritma tasarımı",
      "D": "Veri türü",
      "E": "Veri yapısı"
    },
    "explanation": "Algoritma adımlarının çalışması için gerekli sürenin yani zaman karmaşıklığının alt ve üst sınırlarının matematiksel olarak gösterilmesini sağlayan bir algoritma analizi metodudur. Algoritmaların asimptotik analizi, Büyük O notasyonu ile ifade edilmektedir.<br/>Bir algoritmanın büyük girdiler karşısındaki davranışını inceleyen matematiksel yönteme Asimptotik analiz adı verilmektedir."
  },
  {
    "id": "3623936",
    "unitNumber": 1,
    "text": "Bir sayının asal sayı olup olmadığını gösteren algoritmanın zaman karmaşıklığını aşağıdakilerden hangisi gösterir?",
    "correctAnswer": "A",
    "options": {
      "A": "O(sqrt(N))",
      "B": "O(NLogN)",
      "C": "O(N²)",
      "D": "O(N³)",
      "E": "O(N!)"
    },
    "explanation": "Kod 1.7<br/>bool asalSayimi(int sayi) {<br/>if (sayi == 2) return true;<br/>if (sayi &lt; 2) return false;<br/>for (int i = 2; i &lt;= sqrt(sayi); i ++)<br/>if (sayi%i == 0) return false;<br/>return true;<br/>}<br/>Algoritmanın çalışma süresi, girdi boyutunun karekökü kadar azaltılır. Örnek olarak, bir sayının asal olup olmadığını sadece karekökü olana kadar döngüye girerek kontrol edilebilir."
  },
  {
    "id": "3841764",
    "unitNumber": 1,
    "text": "<em>Veri yapıları, verilerin bilgisayar ortamında ________ ve ________ en kolay yolunu sağlar.</em><br/>Yukarıdaki ifadede boş bırakılan yere aşağıdaki seçeneklerden hangisi <strong>gelmelidir</strong>?",
    "correctAnswer": "B",
    "options": {
      "A": "işlenmesi - yazdırılması",
      "B": "depolanması - işlenmesi",
      "C": "silinmesi - taşınması",
      "D": "sıkıştırılması - kopyalanması",
      "E": "kontrol edilmesi - aktarılması"
    },
    "explanation": "Veri yapısı bilgisayardaki dijital verileri <strong>depolamanın</strong> ve bu veriler üzerinde farklı eylemleri <strong>gerçekleştirmenin en kolay yolunu sağlayan</strong> bir veri öğeleri grubudur.<br/><strong>Depolamak:</strong> Verilerin RAM veya disk gibi donanımlarda uygun şekilde saklanmasını sağlar.<br/><strong>İşlemek:</strong> Bu depolanan veriler üzerinde sıralama, arama, güncelleme, ekleme, silme gibi işlemler yapılmasını ifade eder.<br/><strong>A) işlenmesi - yazdırılması:</strong><br/>Yazdırma (output) veri yapısının ana işlevi değildir, bu daha çok \"çıkış işlemi\"dir. Sadece işleme ve yazdırma kombinasyonu eksik bir ifadedir.<br/><strong>C) silinmesi - taşınması:</strong><br/>Silme ve taşıma işlemleri veri yapılarıyla yapılabilir ama bunlar temel değil, ikincil işlemlerdir.<br/><strong>D) sıkıştırılması - kopyalanması:</strong><br/>Bu işlemler daha çok veri sıkıştırma algoritmaları ve dosya sistemleri ile ilgilidir. Veri yapılarının doğrudan fonksiyonları değildir.<br/><strong>E) kontrol edilmesi - aktarılması:</strong><br/>Kontrol ve veri aktarımı, ağ protokolleri ve işletim sistemi düzeyindeki işlemlerdir. Veri yapılarının ana amacıyla ilgili değildir.<br/>Doğru cevap B seçeneğidir."
  },
  {
    "id": "3841768",
    "unitNumber": 1,
    "text": "Aşağıdakilerden hangisi veri türlerine örnek olarak <strong>verilemez</strong>?",
    "correctAnswer": "C",
    "options": {
      "A": "int",
      "B": "float",
      "C": "queue",
      "D": "bool",
      "E": "char"
    },
    "explanation": "<h4>A) <code>int</code></h4><br/><ul><br/><li><br/>Veri türüdür.<br/></li><br/><li><br/>Tamsayıları temsil eder. Örneğin: <code>int sayi = 42;</code><br/></li><br/></ul><br/><h4>B) <code>float</code></h4><br/><ul><br/><li><br/>Veri türüdür.<br/></li><br/><li><br/>Ondalıklı (kayan noktalı) sayılar için kullanılır. Örneğin: <code>float pi = 3.14f;</code><br/></li><br/></ul><br/><h4>D) <code>bool</code></h4><br/><ul><br/><li><br/>Veri türüdür.<br/></li><br/><li><br/>Mantıksal değerleri ifade eder (true/false). Örneğin: <code>bool aktifMi = true;</code><br/></li><br/></ul><br/><h4>E) <code>char</code></h4><br/><ul><br/><li><br/>Veri türüdür.<br/></li><br/><li><br/>Tek bir karakter tutar. Örneğin: <code>char harf = 'A';</code><br/></li><br/></ul><br/><h4>C) <code>queue</code></h4><br/><ul><br/><li><br/>Veri türü değil, veri yapısıdır.<br/></li><br/><li><br/><code>queue</code> (kuyruk) bir veri yapısıdır ve veri türü gibi doğrudan bir değeri temsil etmez.<br/></li><br/><li><br/>Örneğin: C# veya Java’da <code>Queue<int> kuyruk = new Queue<int>();</int></int></code> gibi tanımlanır.<br/></li><br/><li><br/>Kuyruk yapısı, \"ilk giren ilk çıkar (FIFO)\" prensibiyle çalışır.<br/></li><br/></ul><br/><h3>Temel Fark:</h3><br/><table><thead><tr><th>Kavram</th><th>Tanım</th><th>Örnek</th></tr></thead><tbody><tr><td>Veri Türü</td><td>Değişkenin taşıyacağı veri biçimi</td><td><code>int</code>, <code>float</code>, <code>char</code>, <code>bool</code></td></tr><tr><td>Veri Yapısı</td><td>Verilerin organize edilme şekli</td><td><code>queue</code>, <code>stack</code>, <code>list</code></td></tr></tbody></table>"
  },
  {
    "id": "3841769",
    "unitNumber": 1,
    "text": "Aşağıdakilerden hangisi bir veri yapısının avantajlarından biri <strong>değildir</strong>?",
    "correctAnswer": "D",
    "options": {
      "A": "Hafızanın verimli kullanılması",
      "B": "İşlem hızının artırılması",
      "C": "Soyutlama sağlaması",
      "D": "Kod okunabilirliğini azaltması",
      "E": "Yeniden kullanılabilir olması"
    },
    "explanation": "<h4>A) Hafızanın verimli kullanılması</h4> <ul> <li> Doğrudur. Veri yapıları, belleğin gereksiz kullanımını engelleyerek verimli depolamaya olanak tanır.<br/>Örneğin, sabit boyutlu dizi yerine bağlı liste kullanmak dinamik alan yönetimi sağlar.<br/></li> </ul> <h4>B) İşlem hızının artırılması</h4> <ul> <li> Doğrudur. Etkin veri yapısı kullanımı (örneğin: <code>hash table</code> veya <code>ağaç</code>) işlem sürelerini ciddi şekilde azaltabilir.<br/></li> </ul> <h4>C) Soyutlama sağlaması</h4> <ul> <li> Doğrudur. Veri yapıları, verilerin nasıl tutulduğunu soyutlayarak programcının sadece işlevselliğe odaklanmasını sağlar.<br/>Örneğin: Yığın (stack) kullanırken yalnızca push/pop metodunu bilmek yeterlidir, alt yapı detayları soyutlanır.<br/></li> </ul> <h4>D) Kod okunabilirliğini azaltması</h4> <ul> <li> Yanlıştır. İyi tanımlanmış veri yapıları kodun okunabilirliğini artırır, azaltmaz.<br/><ul> <li> Net sınıf ve metod kullanımı kodun bakımını kolaylaştırır.<br/></li> <li> Karmaşık işlemler basitleşir ve modüler hale gelir.<br/></li> </ul> </li> </ul> <h4>E) Yeniden kullanılabilir olması</h4> <ul> <li> Doğrudur. Veri yapıları, birden fazla projede tekrar tekrar kullanılabilir. Özellikle kütüphane sınıfları olarak tasarlanmış veri yapıları tekrar kullanımı destekler.<br/></li> </ul> <h3> Sonuç:</h3> <ul> <li> Veri yapıları yazılım mühendisliğinde birçok fayda sağlar.<br/></li> <li> Ancak D şıkkındaki ifade, veri yapılarının avantajı değil, aksi bir durumdur.<br/></li> <li> Bu yüzden doğru cevap: D) Kod okunabilirliğini azaltması<br/></li> </ul>"
  },
  {
    "id": "3841770",
    "unitNumber": 1,
    "text": "<em>Bir algoritma oluşturulurken problemin net tanımı yapılmalı ve alınacak ________ ile beklenen ________ belirlenmelidir.</em><br/>Yukarıdaki ifadede boş bırakılan yere aşağıdaki seçeneklerden hangisi <strong>gelmelidir</strong>?",
    "correctAnswer": "C",
    "options": {
      "A": "çözüm - formül",
      "B": "çıktı - sonuç",
      "C": "girdi - çıktı",
      "D": "etki - tepki",
      "E": "analiz - algoritma"
    },
    "explanation": "<em>Bir algoritma yazmak için şu adımlar izlenmelidir:</em><br/><ul><br/><li><br/>Problemin net tanımı yapılmalıdır<br/></li><br/><li><br/>Girdi belirlenmelidir<br/></li><br/><li><br/>Beklenen çıktı tanımlanmalıdır<br/></li><br/><li><br/>Kısıtlar göz önünde bulundurulmalıdır<br/></li><br/><li><br/>Çözüm, bu parametrelere uygun hazırlanmalıdır<br/></li><br/></ul><br/><h4>Girdi (Input) Nedir?<br/>Algoritmanın başında kullanıcıdan alınan veya dış dünyadan gelen verilerdir.<br/>Örneğin: Bir dairenin alanını hesaplayan algoritma için yarıçap bir girdidir.</h4><br/><h4>Çıktı (Output) Nedir?<br/>Algoritmanın sonunda üretilen sonuçlardır.<br/>Örneğin: Dairenin alanı (πr²) çıktıdır.</h4><br/>A) çözüm - formül<br/><ul><br/><li><br/>\"Çözüm\" sürecin kendisi, \"formül\" sadece bir matematiksel ifadedir. Algoritma tanımında yetersizdir.<br/></li><br/></ul><br/>B) çıktı - sonuç<br/><ul><br/><li><br/>\"Çıktı\" ve \"sonuç\" aynı anlama gelir, bu ifade tekrar içerir.<br/></li><br/></ul><br/>D) etki - tepki<br/><ul><br/><li><br/>Bu daha çok fiziksel sistemlerde kullanılan bir kavramdır, algoritma bağlamında belirsizdir.<br/></li><br/></ul><br/>E) analiz - algoritma<br/><ul><br/><li><br/>Bu ifade de kavram karmaşasına yol açar. Analiz süreciyle algoritma oluşturmak farklı aşamalardır.<br/></li><br/></ul><br/>Doğru cevap C) girdi - çıktı çünkü algoritmanın amacı, verilen girdilere göre anlamlı çıktılar üretmektir."
  },
  {
    "id": "3841771",
    "unitNumber": 1,
    "text": "Bir öğrenci not hesaplama sistemi için algoritma yazılmak isteniyor. Hangi adım ilk olarak <strong>gerçekleştirilmelidir</strong>?",
    "correctAnswer": "E",
    "options": {
      "A": "Akış şeması çizimi",
      "B": "Çözüm algoritması oluşturma",
      "C": "Kodlama yapmak",
      "D": "Programlama dili belirleme",
      "E": "Problemin net tanımı"
    },
    "explanation": "Algoritma yazmak için ön koşul olarak aşağıdakilere ihtiyaç vardır:<br/><ul> <li> Bu algoritma ile çözülecek problemin net tanımı yapılmalıdır.*<br/></li> <li> Girdiler belirlenmelidir<br/></li> <li> Beklenen çıktı tanımlanmalıdır<br/></li> <li>Kısıtlar göz önüne alınmalıdır\"</li> </ul><br/>Neden \"problemin net tanımı\" ilk adımdır?<br/><ul> <li> Algoritmanın temelini oluşturur.<br/></li> <li> Ne çözüleceği bilinmezse neyi yazacağımız da belli olmaz.<br/></li> <li> Belirsiz ya da eksik tanımlanmış bir problem → hatalı algoritma.<br/></li> <li> Girdiler ve çıktılar ancak problemin ne olduğu anlaşıldıktan sonra belirlenebilir.<br/></li> </ul> Bu nedenle ilk yapılması gereken:<br/>“E) Problemin net tanımı”dır."
  },
  {
    "id": "3841772",
    "unitNumber": 1,
    "text": "Aşağıdaki karmaşıklık terimlerinden hangileri sabitten<strong> büyüktür</strong> ama n²’den <strong>küçüktür</strong>?<br/><strong>I.</strong> O(log n)<br/><strong>II.</strong> O(n)<br/><strong>III.</strong> O(n log n)<br/><strong>IV.</strong> O(n<sup>3</sup>)",
    "correctAnswer": "D",
    "options": {
      "A": "Yalnız II",
      "B": "Yalnız IV",
      "C": "I ve II",
      "D": "I, II ve III",
      "E": "I, II ve IV"
    },
    "explanation": "Zaman karmaşıklıklarının artış sırası:<br/>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!)<br/><em>Hangi karmaşıklık terimleri O(1)’den (sabitten) büyük, ama O(n²)’den küçüktür?</em><br/><h4>I. O(log n)</h4><br/><ul><br/><li><br/>Sabitten büyüktür.<br/></li><br/><li><br/>n²’den küçüktür. Dahil edilir.<br/></li><br/></ul><br/><h4>II. O(n)</h4><br/><ul><br/><li><br/>O(log n)’den büyük, O(n²)’den küçük Dahil edilir.<br/></li><br/></ul><br/><h4>III. O(n log n)</h4><br/><ul><br/><li><br/>O(n)’den büyük ama O(n²)’den küçüktür Dahil edilir.<br/></li><br/></ul><br/><h4>IV. O(n³)</h4><br/><ul><br/><li><br/>O(n²)’den büyüktür. Dahil edilmez.<br/></li><br/></ul><br/>Doğru cevap: D) I, II ve III"
  },
  {
    "id": "3841773",
    "unitNumber": 1,
    "text": "<ol><br/><li>Algoritma başlatılır.<br/></li><br/><li>Kullanıcıdan bir sayi alınır.<br/></li><br/><li>sayi % 2 == 0 koşulu test edilir.<br/></li><br/><li>Koşul doğruysa “Çift sayı” yazdırılır.<br/></li><br/><li>Koşul yanlışsa “Tek sayı” yazdırılır.<br/></li><br/><li>Algoritma sonlandırılır.</li><br/></ol><br/>Yukarıda verilen algoritma adımları için doğru sembol eşleştirmesi aşağıdaki seçeneklerden hangisinde <strong>yer almaktadır</strong>?",
    "correctAnswer": "A",
    "options": {
      "A": "<ol><br/><li>Başlangıç/Bitiş<br/></li><br/><li>Giriş/Çıkış<br/></li><br/><li>Karar<br/></li><br/><li>İşlem<br/></li><br/><li>İşlem</li><br/><li>Başlangıç/Bitiş</li><br/></ol>",
      "B": "<ol><br/><li>İşlem<br/></li><br/><li>Giriş/Çıkış<br/></li><br/><li>Giriş/Çıkış<br/></li><br/><li>Karar<br/></li><br/><li>İşlem</li><br/><li>İşlem</li><br/></ol>",
      "C": "<ol><br/><li>Giriş/Çıkış<br/></li><br/><li>İşlem<br/></li><br/><li>Karar<br/></li><br/><li>İşlem<br/></li><br/><li>Giriş/Çıkış<br/></li><br/><li>Başlangıç/Bitiş</li><br/></ol>",
      "D": "<ol><br/><li>Başlangıç/Bitiş<br/></li><br/><li>İşlem<br/></li><br/><li>İşlem<br/></li><br/><li>Karar<br/></li><br/><li>İşlem<br/></li><br/><li>Başlangıç/Bitiş</li><br/></ol>",
      "E": "<ol><br/><li>Başlangıç/Bitiş<br/></li><br/><li>Giriş/Çıkış<br/></li><br/><li>Karar<br/></li><br/><li>Giriş/Çıkış<br/></li><br/><li>Giriş/Çıkış<br/></li><br/><li>İşlem</li><br/></ol>"
    },
    "explanation": "<table><thead><tr><th>Adım No</th><th>Ne yapılıyor?</th><th>Doğru Sembol</th><th>Açıklama</th></tr></thead><tbody><tr><td>1</td><td>Başlat</td><td>Başlangıç/Bitiş (oval)</td><td>Algoritmanın başlangıcıdır.</td></tr><tr><td>2</td><td>Veri girişi (<code>sayi</code>)</td><td>Giriş/Çıkış (paralelkenar)</td><td>Kullanıcıdan bilgi alınır.</td></tr><tr><td>3</td><td>Koşul testi (<code>sayi % 2 == 0</code>)</td><td>Karar (elmas)</td><td>Mantıksal kontrol yapılır.</td></tr><tr><td>4</td><td>“Çift sayı” yazdırılır</td><td>İşlem (dikdörtgen)</td><td>Bir işlem gerçekleştirilir.</td></tr><tr><td>5</td><td>“Tek sayı” yazdırılır</td><td>İşlem (dikdörtgen)</td><td>Alternatif bir işlem yapılır.</td></tr><tr><td>6</td><td>Sonlandırma</td><td>Başlangıç/Bitiş (oval)</td><td>Akış sona erer.</td></tr></tbody></table>"
  },
  {
    "id": "3841774",
    "unitNumber": 1,
    "text": "<em>A = 1</em><br/><em> B = 2</em><br/><em> for i = 1 to n:</em><br/><em> for j = 1 to n:</em><br/><em> A = A + i + j</em><br/><em> for k = 1 to n:</em><br/><em> B = B * k</em><br/><em> return A + B</em><br/>Bu algoritmanın zaman karmaşıklığı Big O notasyonu hangi seçenekte <strong>doğru olarak verilmiştir</strong>?",
    "correctAnswer": "B",
    "options": {
      "A": "O(n³)",
      "B": "O(n²)",
      "C": "O(n log n)",
      "D": "O(n)",
      "E": "O(1)"
    },
    "explanation": "<h4><code>A = 1</code> ve <code>B = 2</code></h4><br/><ul><br/><li><br/>Sabit süreli işlemlerdir → O(1)<br/></li><br/></ul><br/><h4><code>for i = 1 to n:</code></h4><br/><code>for j = 1 to n:</code><br/><code>A = A + i + j</code><br/><ul><br/><li><br/>Bu iç içe döngü n × n = n² kez çalışır.<br/>→ O(n²)<br/></li><br/></ul><br/><h4><code>for k = 1 to n:</code></h4><br/><code>B = B * k</code><br/><ul><br/><li><br/>Bu tek döngü n kez çalışır.<br/>→ O(n)<br/></li><br/></ul><br/><h4>Toplam Karmaşıklık:</h4><br/><ul><br/><li><br/>O(1) + O(n²) + O(n)<br/></li><br/><li><br/>Asimptotik olarak baskın olan terim belirleyici olur → Doğru Cevap: B) O(n²)<br/></li><br/></ul>"
  },
  {
    "id": "3841775",
    "unitNumber": 1,
    "text": "Bu algoritma için aşağıda verilen parçalardan doğru bir akış şeması oluşturulmak istenmektedir. Aşağıdaki eşleşmelerden <strong>hangisi hatalıdır?</strong>",
    "correctAnswer": "E",
    "options": {
      "A": "Sayı girişi için <strong>paralelkenar</strong> sembolü kullanılmalıdır.",
      "B": "Tek sayı kontrolü için <strong>karar (elmas)</strong> sembolü kullanılmalıdır.",
      "C": "Toplam = Toplam + i işlemi için <strong>işlem (dikdörtgen)</strong> sembolü kullanılır.",
      "D": "i'nin her artışında <strong>i = i + 1</strong> işlemi bir <strong>işlem (dikdörtgen)</strong> kutusunda gösterilmelidir.",
      "E": "Döngü başlangıcı (i = 1) için <strong>başlangıç/bitiş (oval)</strong> sembolü kullanılır."
    },
    "explanation": "<h4>Doğru Cevap: E) Döngü başlangıcı (i = 1) için başlangıç/bitiş (oval) sembolü kullanılır.</h4> <ul> <li> Oval şekil, yalnızca algoritmanın başlatıldığı veya sonlandığı yerdir.<br/></li> <li> Değişken başlatma (<code>i = 1</code>) bir işlem olduğu için dikdörtgen ile gösterilmelidir.<br/></li> </ul>"
  },
  {
    "id": "3841776",
    "unitNumber": 1,
    "text": "<em>def kosulluIslem(n):</em><br/><em> for i in range(n):</em><br/><em> if i % 2 == 0:</em><br/><em> for j in range(n):</em><br/><em> print(i, j)</em><br/>Bu algoritmanın zaman karmaşıklığı Big O notasyonu hangi seçenekte <strong>doğru olarak verilmiştir</strong>?",
    "correctAnswer": "A",
    "options": {
      "A": "O(n²)",
      "B": "O(n log n)",
      "C": "O(5n)",
      "D": "O(n)",
      "E": "O(1)"
    },
    "explanation": "<h4>Dış döngü:</h4><br/><code>for i in range(n): </code><br/><ul><br/><li><br/><code>n</code> kez döner → O(n)<br/></li><br/></ul><br/><h4>Koşul:</h4><br/><code>if i % 2 == 0:</code><br/><ul><br/><li><br/>Bu koşul n/2 kez doğrudur (çift sayılar için), ancak Big O notasyonunda sabit çarpanlar dikkate alınmaz.<br/></li><br/><li><br/>Yani bu döngü yaklaşık n/2 kez iç döngüyü çalıştırır → yine de O(n) kabul edilir.<br/></li><br/></ul><br/><h4>İç döngü:</h4><br/><code>for j in range(n):</code><br/><ul><br/><li><br/><code>n</code> kez çalışır → O(n)<br/></li><br/></ul><br/><h4>Toplam karmaşıklık:</h4><br/><ul><br/><li><br/>İç döngü yaklaşık <code>n/2</code> kez çalışsa da → O(n) × O(n) = O(n²) Doğru cevap budur.<br/></li><br/></ul>"
  },
  {
    "id": "3623977",
    "unitNumber": 2,
    "text": "Veri yapıları, bilgisayardaki verileri etkin bir şekilde kullanılabilecek şekilde düzenlemenin özel bir yoludur. Aşağıdakilerden hangisi sık kullanılan veri yapılardan değildir?",
    "correctAnswer": "A",
    "options": {
      "A": "Permütasyon",
      "B": "Sözlük",
      "C": "Küme",
      "D": "Dizi",
      "E": "Liste"
    },
    "explanation": "Permütasyon, diğer seçeneklerden farklı olarak sık kullanılan veri yapılardan değildir."
  },
  {
    "id": "3623978",
    "unitNumber": 2,
    "text": "Bir dizi, bitişik bellek konumlarında depolanan ögeler topluluğudur. Buradaki amaç, aynı türden birden fazla ögeyi bir arada saklamaktır. Bu yapıda, bir temel değere yani dizinin ilk ögesinin bellek konumuna (genellikle dizinin adı ile gösterilir) bir ........................... eklenerek her bir ögenin konumunun hesaplanması kolaylaştırılmaktadır.<br/>Yukarıda yer alan metindeki boşluğa aşağıdakilerden hangisi gelmelidir?",
    "correctAnswer": "B",
    "options": {
      "A": "Küme",
      "B": "Ofset",
      "C": "Sembol",
      "D": "Değişken",
      "E": "Kelime"
    },
    "explanation": "Doğru yanıt <strong>ofset</strong>'tir."
  },
  {
    "id": "3623979",
    "unitNumber": 2,
    "text": "Bir tek boyutlu dizi, şu değerlere sahip yedi eleman içersin: a, n, a, d, o, l ve u. İlk elemanın indeksi 0’a eşitse son elemanın indeksi kaç olur?",
    "correctAnswer": "C",
    "options": {
      "A": "-6",
      "B": "7",
      "C": "6",
      "D": "-7",
      "E": "0"
    },
    "explanation": "Tek boyutlu bir dizi, bir dizin tarafından erişilebilen aynı türdeki ögelerin bir koleksiyonunu depolamaktadır. C#’daki dizi indekslerinin sıfır tabanlı olduğu unutulmamalıdır. Bu, ilk ögenin indeksinin 0 olduğu, sonuncusunun ise dizinin uzunluğundan bir eksik indekse sahip olduğu anlamına gelmektedir. Dolayısıyla, İlk elemanın indeksi 0’a eşitken son elemanın indeksi 6 olur."
  },
  {
    "id": "3623980",
    "unitNumber": 2,
    "text": "Hash tablosunun en önemli varsayımlarından biri; Anahtara dayalı bir Değer için çok hızlı arama<br/>yapabilen, O(1) işlem karmaşıklığında arama işlemi yapabilmesi gerekmektedir. Bu amaca ulaşmak için Hash Fonksiyonu kullanılmaktadır. Değerin bulunabileceği bir Kova dizini (bucket) oluşturmak için ................................................. gerekmektedir.<br/>Yukarıda yer verilen metindeki boş bırakılan yere aşağıdakilerden hangisi gelmelidir?",
    "correctAnswer": "A",
    "options": {
      "A": "Anahtar",
      "B": "Algoritma",
      "C": "Dizi",
      "D": "Sözlük",
      "E": "Küme"
    },
    "explanation": "Doğru yanıt, <strong>anahtar</strong>'dır."
  },
  {
    "id": "3623981",
    "unitNumber": 2,
    "text": "Hashtable sınıfı, hash tablosuyla ilgili sınıfların jenerik olmayan bir varyantıdır ancak anahtar ve değer için bir değişken tipi belirlenmesine izin vermediği için önemli bir sınırlaması vardır. Sözlük veri yapısında bu sınırlama kaldırılmıştır. DictionaryEntry sınıfının Key ve Value özelliklerinin ikisi de nesne türündedir bu nedenle tüm anahtarlar ve değerler aynı tipte olsa bile .......................................................................... işlemleri yapılması gerekmektedir.<br/>Yukarıda yer verilen metindeki boş kısma aşağıdakilerden hangisi gelmelidir?",
    "correctAnswer": "C",
    "options": {
      "A": "Çarpma ve ters fonksiyon",
      "B": "Değer verme ve permütasyon",
      "C": "Kutulama ve kutudan çıkarma",
      "D": "Kümeleme ve kombinasyon",
      "E": "İndeksleme ve kümeleme"
    },
    "explanation": "Doğru yanıt, kutulama (boxing) ve kutudan çıkarma (unboxing) işlemleri olmalıdır."
  },
  {
    "id": "3623982",
    "unitNumber": 2,
    "text": "Hash tabloları ile ilgili sınıfların hem genel olmayan hem de genel türevleri, ögelerin sırasını tutmaz bu nedenle koleksiyondaki verilere anahtarlara göre sıralanmış şekilde erişmek gerekiyorsa bunların kullanımdan önce sıralanması gerekir ancak bu sorunu çözmek ve anahtarları her zaman sıralı tutmak için başka bir veri yapısı olarak aşağıdakilerden hangisi kullanılabilir?",
    "correctAnswer": "B",
    "options": {
      "A": "Karma küme",
      "B": "Sıralanmış sözlük",
      "C": "Fonksiyonel küme",
      "D": "Aritmetik sözlük",
      "E": "Sıralanmış küme"
    },
    "explanation": "Doğru yanıt, <strong>sıralanmış sözlük</strong> olmalıdır."
  },
  {
    "id": "3623983",
    "unitNumber": 2,
    "text": "C# dilinde uygulama geliştirirken System.Collections.Generic ad alanından HashSet sınıfının sağladığı yüksek performanslı işlemlerden yararlanılabilir. HashSet sınıfı, kümedeki ögelerin sayısını döndüren Count dahil olmak üzere birkaç özellik içermektedir. Ayrıca, küme işlemlerini gerçekleştirmek için birçok yöntem kullanılabilir.<br/>Yaygın olarak kullanılan bir yöntemde, parametre olarak gönderilen küme ile yöntemin çağrıldığı geçerli kümeyi değiştirmeyi mümkün kılarak aşağıdakilerden hangisi oluşturulamaz?",
    "correctAnswer": "D",
    "options": {
      "A": "Birleşim",
      "B": "Kesişme",
      "C": "Çıkarma",
      "D": "Toplama",
      "E": "Simetrik fark"
    },
    "explanation": "İlk yöntem grubu, parametre olarak gönderilen küme ile aşağıdakileri oluşturmak için yöntemin çağrıldığı geçerli kümeyi değiştirmeyi mümkün kılmaktadır:<br/>• Birleşim (UnionWith)<br/>• Kesişme (IntersectWith)<br/>• Çıkarma (ExceptWith)<br/>• Simetrik fark (SmetricExceptWith)<br/>Bunların arasında toplama bulunmamaktadır, doğru yanıt D seçeneğidir."
  },
  {
    "id": "3623984",
    "unitNumber": 2,
    "text": "List<t>; dizine göre erişilebilen ve sıralama, arama ve listeyi değiştirme yöntemlerine sahip, kesin olarak girilmiş nesneler topluluğudur. System.Collections.Generic ad alanı altında gelen ArrayList’in genel sürümüdür. Aşağıdakilerden hangisi, List<t>'nin özellikleri arasında yer almaz?</t></t>",
    "correctAnswer": "E",
    "options": {
      "A": "List<t>, IList<t> arayüzünü uygulayan ArrayList’in eşdeğeridir.</t></t>",
      "B": "System.Collections.Generic ad alanı altında gelir.",
      "C": "Ögeler, Add(), AddRange() yöntemleri veya koleksiyon başlatıcı sözdizimi kullanılarak eklenebilir.",
      "D": "Ögelere bir dizin geçirilerek erişilebilir, örneğin listem[0]. İndeksler sıfırdan başlar.",
      "E": "List<t>, belirtilen türdeki ögeleri içerebilir. Derleme zamanı tür denetimi sağlar ve kutulama/kutudan çıkarma işlemlerini gerçekleştirir.</t>"
    },
    "explanation": "List<t>, belirtilen türdeki ögeleri içerebilir. Derleme zamanı tür denetimi sağlar ve genel olduğu için kutulama/kutudan çıkarma (boxing/unboxing) gerçekleştirmez.</t>"
  },
  {
    "id": "3624139",
    "unitNumber": 2,
    "text": "Aşağıdaki veri yapılarından hangisinin eleman sayısı ilk değer atama işleminden sonra değiştirilemez?",
    "correctAnswer": "A",
    "options": {
      "A": "Dizi",
      "B": "Sözlük",
      "C": "Küme",
      "D": "Hash Tabloları",
      "E": "Dizi Listesi"
    },
    "explanation": "Dizi işlemlerinde önemli olan, bir dizideki eleman sayısının ilk değer atama (initialization) işleminden sonra değiştirilememesidir bu nedenle dizinin sonuna veya dizi içinde belirli bir konuma kolayca yeni bir öge eklenememektedir. Bu tür özelliklere ihtiyaç varsa genel listeler gibi diğer veri yapılarını kullanabilirsiniz.<br/>Dizi işlemlerinde önemli olan, bir dizideki eleman sayısının ilk değer atama (initialization) işleminden sonra değiştirilememesidir."
  },
  {
    "id": "3624140",
    "unitNumber": 2,
    "text": "<img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/bf74a6b713ac248763709bcf8ef11c97.png\" alt=\"\" width=\"176\" height=\"155\"> \"sayilar[3][2] = 100\" kodu yukarıdaki çok boyutlu dizi örneğinde hangi elemanın değerini 100 ile değiştirir?",
    "correctAnswer": "D",
    "options": {
      "A": "2",
      "B": "5",
      "C": "7",
      "D": "12",
      "E": "15"
    },
    "explanation": "sayilar[3][2] = 100 kodu soru kökünde verilen dizinin dördüncü satır ve üçüncü sütunundaki eleman olan 12'yi 100 ile değiştirir."
  },
  {
    "id": "3624141",
    "unitNumber": 2,
    "text": "Aşağıdaki yapılardan hangisi anahtara dayalı bir değer için çok hızlı arama yapabilmektedir?",
    "correctAnswer": "A",
    "options": {
      "A": "Hash tabloları",
      "B": "Sözlükler",
      "C": "Sıralanmış sözlükler",
      "D": "Karma kümeler",
      "E": "Sıralanmış kümeler"
    },
    "explanation": "Hash tablosunun en önemli varsayımlarından biri; Anahtara dayalı bir Değer için çok hızlı arama yapabilen, O(1) işlem karmaşıklığında arama işlemi yapabilmesi gerekmektedir. Bu amaca ulaşmak için Hash Fonksiyonu kullanılmaktadır. Değerin bulunabileceği bir Kova dizini (bucket) oluşturmak için Anahtar (key) gerekmektedir. Böylece anahtarın bir değerini bulmanız gerekiyorsa koleksiyondaki tüm ögelerin üzerinden tek tek geçilmesi gerekmez çünkü anahtara karşılık gelen uygun bir kovayı kolayca bulmak ve değeri almak için hash fonksiyonunu kullanabilirsiniz. Hash tablosunun mükemmel performansı sebebiyle bu veri yapısı; ilişkisel diziler, veritabanı indeksleri veya önbellek sistemleri gibi birçok gerçek dünya uygulamasında sıklıkla kullanılmaktadır."
  },
  {
    "id": "3624152",
    "unitNumber": 2,
    "text": "Aşağıdakilerden hangisi sözlük veri yapısının hash tablosundan farkını açıklar?",
    "correctAnswer": "A",
    "options": {
      "A": "Anahtar ve değer için bir değişken tipi belirlenmesine izin verir.",
      "B": "Belirli bir ögeye erişmek için dizinleyiciyi kullanılabilir.",
      "C": "Anahtar null değerine eşit olamaz.",
      "D": "Aynı anahtar birden fazla kullanılamaz.",
      "E": "İndeksleyici kullanılarak belirli bir ögeye kolayca erişilebilir."
    },
    "explanation": "Hashtable sınıfı, hash tablosuyla ilgili sınıfların jenerik olmayan bir varyantıdır ancak anahtar ve değer için bir değişken tipi belirlenmesine izin vermediği için önemli bir sınırlaması vardır. Sözlük veri yapısında bu sınırlama kaldırılmıştır. DictionaryEntry sınıfının Key ve Value özelliklerinin ikisi de nesne türündedir bu nedenle tüm anahtarlar ve değerler aynı tipte olsa bile kutulama (boxing) ve kutudan çıkarma (unboxing) işlemleri yapılması gerekmektedir. Hashtable sınıfına benzer şekilde, belirli bir ögeye erişmek için dizinleyiciyi de kullanılabilir."
  },
  {
    "id": "3624153",
    "unitNumber": 2,
    "text": "Sıralanmış sözlük yapısında ulaşılmak istenen öge koleksiyonda bulunamaz ise aşağıdaki hatalardan hangisi alınacaktır?",
    "correctAnswer": "A",
    "options": {
      "A": "KeyNotFoundException",
      "B": "Run-time exception",
      "C": "OutOfMemory",
      "D": "No such file or directory",
      "E": "Type mismatch"
    },
    "explanation": "Hash tabloları ile ilgili sınıfların hem genel olmayan hem de genel türevleri, ögelerin sırasını tutmaz bu nedenle koleksiyondaki verilere anahtarlara göre sıralanmış şekilde erişmek gerekiyorsa bunların kullanımdan önce sıralanması gerekir ancak bu sorunu çözmek ve anahtarları her zaman sıralı tutmak için başka bir veri yapısı, sıralanmış sözlük kullanılabilir. Böylece gerektiğinde tasnif edilmiş koleksiyona kolayca ulaşılabilir. Ulaşılmak istenilen ögenin koleksiyonda var olduğundan emin olunmalıdır aksi takdirde KeyNotFoundException hatası alınacaktır."
  },
  {
    "id": "3624154",
    "unitNumber": 2,
    "text": "Sıralanmış sözlük sınıfında tüm ögeleri kaldırmak için aşağıdakilerden yöntemlerden hangisi kullanılır?",
    "correctAnswer": "D",
    "options": {
      "A": "Count",
      "B": "Add",
      "C": "Remove",
      "D": "Clear",
      "E": "TryGetValue"
    },
    "explanation": "Sıralanmış sözlüklerde tüm ögeleri kaldırmak için (Clear) yöntemi kullanılır.<br/>Sıralanmış sözlük sınıfı, içerdiği ögelerin sayısını (Count) almayı ve ayrıca anahtarlar ve değerler koleksiyonunu (sırasıyla Keys ve Values) döndürmeyi mümkün kılan birkaç özelliğe sahiptir. Ayrıca yeni bir öge eklemek (Add), bir ögeyi kaldırmak (Remove), tüm ögeleri kaldırmak (Clear), ayrıca koleksiyonun belirli bir anahtarı (ContainsKey) ve verilen değeri (ContainsValue) içerip içermediğini kontrol etmek gibi mevcut yöntemler kullanılabilir. Belirli bir anahtar için karşılık gelen bir değer varsa onu döndürmek veya bulunamadıysa null döndürmek için TryGetValue yöntemi kullanılabilir."
  },
  {
    "id": "3624155",
    "unitNumber": 2,
    "text": "<img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/4545a16b40627ea0ad5e2ab64868c4fc.png\" alt=\"\" width=\"422\" height=\"209\"> Yukarıdaki kod parçacığının çıktısı aşağıdakilerden hangisidir?",
    "correctAnswer": "A",
    "options": {
      "A": "1 Eskisehir<br/>2 Kocaeli<br/>3 İstanbul<br/>4 Ankara<br/>5 Antalya",
      "B": "Ankara<br/>Antalya<br/>Eskişehir<br/>İstanbul<br/>Kocaeli",
      "C": "Eskişehir<br/>Ankara<br/>Antalya<br/>İstanbul<br/>Kocaeli",
      "D": "Eskisehir (1), Kocaeli (2), İstanbul (3), Ankara (4), Antalya (5)",
      "E": "Eskisehir, Kocaeli, İstanbul, Ankara, Antalya"
    },
    "explanation": "Buna göre anahtar değerlerine göre sıralanan doğru seçenek A seçeneğidir.<br/>Örnek kodda, 5 adet il adı karışık sıralarda sözlüğe eklenmiştir. Ardından sözlükteki anahtar ve değer çiftleri ekrana bastırılmış ve hepsinin anahtar değerlerine göre sıralandığı görülmektedir."
  },
  {
    "id": "3624156",
    "unitNumber": 2,
    "text": "Kümeler ile ilgili aşağıdakilerden hangisi hatalıdır?",
    "correctAnswer": "E",
    "options": {
      "A": "Bazı algoritmalarda çeşitli veriler içeren kümeler üzerinde işlem yapmak gerekmektedir.",
      "B": "Küme, yinelenen ögeleri ve belirli bir düzeni olmayan farklı nesnelerden oluşan bir koleksiyondur.",
      "C": "Kümeler; birleştirme, kesişme, çıkarma ve simetrik fark gibi matematiksel işlemlerle sıkı bir şekilde ilişkilidir.",
      "D": "Bir küme, tam sayı veya dize değerleri gibi çeşitli verileri depolayabilir.",
      "E": "A \\ B’nin sonuç kümesi, A’nın üyeleri değil, B’nin üyeleri olan ögeleri içerir."
    },
    "explanation": "A \\ B’nin sonuç kümesi, B’nin üyeleri değil, A’nın üyeleri olan ögeleri içerir. Aşağıdaki çizimde, A \\ B ve B \\ A olmak üzere iki örnek sunulmaktadır.<br/><img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/219603af7d5d373e4e6f69fbc96559f0.png\" alt=\"\" width=\"396\" height=\"148\"><br/>Bazı algoritmalarda çeşitli veriler içeren kümeler üzerinde işlem yapmak gerekmektedir. Küme, yinelenen ögeleri ve belirli bir düzeni olmayan farklı nesnelerden oluşan bir koleksiyondur bu nedenle yalnızca belirli bir elemanın kümede olup olmadığını öğrenebilirsiniz. Kümeler; birleştirme, kesişme, çıkarma ve simetrik fark gibi matematiksel modeller ve işlemlerle sıkı bir şekilde ilişkilidir. Bir küme, aşağıdaki şemada gösterildiği gibi tam sayı veya dize değerleri gibi çeşitli verileri depolayabilir. Bunun yanında, kullanıcı tanımlı bir sınıfın örnekleriyle bir küme oluşturulabilir ve istenildiği zaman kümeye öge ekleyip kaldırılabilir."
  },
  {
    "id": "3624157",
    "unitNumber": 2,
    "text": "IsProperSupersetOf yöntemi ile aşağıdaki ilişkilerden hangisi kontrol edilebilir?",
    "correctAnswer": "D",
    "options": {
      "A": "Parametre olarak iletilen kümenin bir alt kümesi",
      "B": "Parametre olarak iletilen kümenin bir üst kümesi",
      "C": "Parametre olarak geçirilen kümenin uygun bir alt kümesi",
      "D": "Parametre olarak geçirilen kümenin uygun bir üst kümesi",
      "E": "Parametre olarak geçirilen kümenin uygun üyesi"
    },
    "explanation": "Yöntemin çağrıldığı geçerli kümede aşağıdaki özellikler kontrol edilebilir:<br/><ul><br/><li>Parametre olarak iletilen kümenin bir alt kümesi (IsSubsetOf)</li><br/><li>Parametre olarak iletilen kümenin bir üst kümesi (IsSupersetOf)</li><br/><li>Parametre olarak geçirilen kümenin uygun bir alt kümesi (IsProperSubsetOf)</li><br/><li>Parametre olarak geçirilen kümenin uygun bir üst kümesi (IsProperSupersetOf) Ayrıca, iki kümenin aynı ögeleri içerip içermediğini (SetEquals) veya iki kümenin en az bir ortak ögeye sahip olup olmadığını (Overlaps) doğrulayabilirsiniz.</li><br/></ul><br/>Parametre olarak geçirilen kümenin uygun bir üst kümesi (IsProperSupersetOf)yöntemi ile kontrol edilebilir.<br/>C# dilinde uygulama geliştirirken System.Collections.Generic ad alanından HashSet sınıfının sağladığı yüksek performanslı işlemlerden yararlanılabilir. HashSet sınıfı, kümedeki ögelerin sayısını döndüren Count dahil olmak üzere birkaç özellik içermektedir. Ayrıca, aşağıdaki gibi küme işlemlerini gerçekleştirmek için birçok yöntem kullanılabilir. İlk yöntem grubu, parametre olarak gönderilen küme ile aşağıdakileri oluşturmak için yöntemin çağrıldığı geçerli kümeyi değiştirmeyi mümkün kılmaktadır:<br/><ul> <li>Birleşim (UnionWith) </li> <li>Kesişme (IntersectWith) </li> <li>Çıkarma (ExceptWith) </li> <li>Simetrik fark (SmetricExceptWith) İki küme arasındaki ilişkiler de kontrol edilebilir.</li> </ul>"
  },
  {
    "id": "3624158",
    "unitNumber": 2,
    "text": "List<t>; dizine göre erişilebilen ve sıralama, arama ve listeyi değiştirme yöntemlerine sahip, kesin olarak girilmiş nesneler topluluğudur. Aşağıdakilerden hangisi List<t> özelliklerindendir?</t></t>",
    "correctAnswer": "A",
    "options": {
      "A": "List<t>, IList<t> arayüzünü uygulayan ArrayList’in eşdeğeridir.</t></t>",
      "B": "Collections.General ad alanı altında gelir.",
      "C": "Ögeler, AddValue() kullanılarak eklenebilir.",
      "D": "List<t>, ArrayList’ten daha yavaş ve daha fazla hataya açık çalışır.</t>",
      "E": "Ögelere bir dizin geçirilerek erişilebilir, örneğin listem[0]. İndeksler birden başlar."
    },
    "explanation": "Açıklamaya göre List<t>, IList<t> arayüzünü uygulayan ArrayList’in eşdeğeridir.</t></t><br/>List<t>; dizine göre erişilebilen ve sıralama, arama ve listeyi değiştirme yöntemlerine sahip, kesin olarak girilmiş nesneler topluluğudur. System.Collections.Generic ad alanı altında gelen ArrayList’in genel sürümüdür.</t><br/>List<t> Özellikleri</t><br/><ul> <li>List<t>, IList<t>varayüzünü uygulayan ArrayList’in eşdeğeridir.</t></t></li> <li>System.Collections.Generic ad alanı altında gelir.</li> <li>List<t>, belirtilen türdeki ögeleri içerebilir. Derleme zamanı tür denetimi sağlar ve genel olduğu için kutulama/kutudan çıkarma (boxing/unboxing) gerçekleştirmez.</t></li> <li>Ögeler, Add(), AddRange() yöntemleri veya koleksiyon başlatıcı sözdizimi kullanılarak eklenebilir.</li> <li>Ögelere bir dizin geçirilerek erişilebilir, örneğin listem[0]. İndeksler sıfırdan başlar.</li> <li>List<t>, ArrayList’ten daha hızlı ve daha az hataya açık çalışır.</t></li> </ul> List<t> genel bir koleksiyondur bu nedenle depolayabileceği veri türü için bir tür parametresi belirtilmesi gerekmektedir.</t>"
  },
  {
    "id": "3845923",
    "unitNumber": 2,
    "text": "Aşağıdaki C# kodunun çıktısı <strong>nedir</strong>?<br/><em>int[] sayilar = { 10, 20, 30, 40, 50 };</em><br/><em>sayilar[2] = sayilar[0] + sayilar[4];</em><br/><em>Console.WriteLine(sayilar[2]);</em>",
    "correctAnswer": "D",
    "options": {
      "A": "10",
      "B": "30",
      "C": "50",
      "D": "60",
      "E": "70"
    },
    "explanation": "<ol> <li> Dizi tanımı (C# dizilerinde indeksler 0’dan başlar):<br/></li> </ol> <ul> <li> <em>sayilar = { 10, 20, 30, 40, 50 }</em><br/></li> <li> İndeksler:<br/>0→10, 1→20, 2→30, 3→40, 4→50<br/></li> </ul> <ol start=\"2\"> <li> Atama ifadesi:<br/><em><code>sayilar[2] = sayilar[0] + sayilar[4];</code></em><br/></li> </ol> <ul> <li> sayilar[0] = 10<br/></li> <li> sayilar[4] = 50<br/></li> <li> Toplam = 10 + 50 = 60<br/></li> <li> Bu değer, indeks 2’deki eski değerin (30) üzerine yazılır.<br/>Yeni durum: { 10, 20, <strong>60</strong>, 40, 50 }<br/></li> </ul> <ol start=\"3\"> <li> Yazdırma:<br/><em><code>Console.WriteLine(sayilar[2]);</code></em> → ekrana 60 yazar.<br/></li> </ol>"
  },
  {
    "id": "3845948",
    "unitNumber": 2,
    "text": "Aşağıdaki tanım hangi dizi türüne aittir?<br/><em>int[,] tablo = new int[4,3];</em>",
    "correctAnswer": "B",
    "options": {
      "A": "Tek boyutlu dizi",
      "B": "Çok boyutlu dizi",
      "C": "Pürüzlü (Jagged) dizi",
      "D": "Hash tablo",
      "E": "Sıralı küme"
    },
    "explanation": "<ul> <li> <strong> Tek boyutlu dizi</strong> → <code>[ ]</code> şeklinde olur, <code>[,]</code> değil.<br/></li> <li> <strong> Çok boyutlu dizi</strong> → <code>[,]</code> ifadesi bu türü belirtir.<br/></li> <li> <strong> Pürüzlü (Jagged) dizi</strong> → <code>int[][]</code> şeklinde tanımlanır, satır uzunlukları farklı olabilir.<br/></li> <li> <strong> Hash tablo</strong> → Anahtar-değer yapısıdır, dizilerle alakalı değil.<br/></li> <li> <strong> Sıralı küme</strong> → Küme veri yapısının özel bir türüdür.<br/></li> </ul>"
  },
  {
    "id": "3845958",
    "unitNumber": 2,
    "text": "Bir Hashtable’da anahtar değeri olarak <code>null</code> atanırsa <strong>ne olur</strong>?",
    "correctAnswer": "A",
    "options": {
      "A": "Hata verir",
      "B": "null olarak saklar",
      "C": "null değeri otomatik olarak “empty” string’e çevirir",
      "D": "Anahtarı yoksayar",
      "E": "Çalışma zamanında rastgele değer atar"
    },
    "explanation": "C#’ta <strong>Hashtable</strong>’da <strong>anahtar (key) için <code>null</code> kullanılamaz</strong>. <code>null</code> bir anahtar eklemeye çalışırsanız <strong>çalışma zamanında hata</strong> alırsınız (Hashtable’de key <code>null</code> olamaz).<br/>Aynı ilke, jenerik sözlükler (Dictionary) için de geçerlidir: <strong>anahtar <code>null</code> olamaz</strong>, ama değer türü izin veriyorsa <strong>value <code>null</code> olabilir</strong>."
  },
  {
    "id": "3845968",
    "unitNumber": 2,
    "text": "Hash tablolarında <strong>O(1)</strong> işlem karmaşıklığını sağlayan bileşen aşağıdakilerden <strong>hangisidir</strong>?",
    "correctAnswer": "E",
    "options": {
      "A": "ContainsKey metodu",
      "B": "Anahtar-değer çifti",
      "C": "SortedList",
      "D": "ArrayList",
      "E": "Hash fonksiyonu"
    },
    "explanation": "<h5><strong>Doğru cevap Hash fonksiyonu;</strong></h5><br/><ul><br/><li><br/><strong>Hash tablolarında</strong> (Hashtable, Dictionary gibi yapılar) veriye hızlı erişim, <strong>hash fonksiyonu</strong> sayesinde olur.<br/></li><br/><li><br/><strong>Hash fonksiyonu</strong>, verilen anahtarı (key) bir sayıya dönüştürür ve bu sayı, <strong>verinin tutulduğu “kova” (bucket) indeksini</strong> belirler.<br/></li><br/><li><br/>Bu sayede arama işlemi, <strong>koleksiyondaki tüm elemanları tek tek gezmeden</strong>, <strong>doğrudan ilgili kovaya</strong> erişerek yapılır.<br/></li><br/><li><br/>İyi tasarlanmış bir hash fonksiyonu ile arama, ekleme ve silme işlemleri <strong>ortalama</strong> olarak <strong>O(1)</strong> zaman karmaşıklığında gerçekleşir.<br/></li><br/></ul><br/><strong>A) ContainsKey metodu</strong> → Hızı sağlayan kendisi değil, arka planda kullandığı hash fonksiyonu.<strong><br/>B) Anahtar-değer çifti</strong> → Sadece veriyi saklama yöntemi; hızın kaynağı değil.<br/><strong>C) SortedList</strong> → Sıralı yapı, arama O(log n); O(1) hız sağlamaz.<br/><strong>D) ArrayList</strong> → İndeksle erişimde hızlı, ama anahtara göre arama yok; genelde O(n)."
  },
  {
    "id": "3845971",
    "unitNumber": 2,
    "text": "Aşağıdaki kod parçası çalıştırıldığında hangi çıktı alınır?<br/><em>var sozluk = new Dictionary<int,string>();</int,string></em><br/><em>sozluk.Add(1, \"Elma\");</em><br/><em>sozluk[1] = \"Armut\";</em><br/><em>Console.WriteLine(sozluk[1]);</em>",
    "correctAnswer": "B",
    "options": {
      "A": "Elma",
      "B": "Armut",
      "C": "null",
      "D": "Çalışma zamanı hatası",
      "E": "Boş string"
    },
    "explanation": "C#’ta <code>Dictionary</code> için <strong>dizinleyici (indexer) ataması</strong> <em>(<code>sozluk[key] = değer</code>)</em> iki iş yapar:<br/><ol><br/><li><br/>Anahtar yoksa <strong>yeni öge ekler</strong>,<br/></li><br/><li><br/>Anahtar varsa <strong>mevcut değeri günceller</strong>.<br/>Bu, kitapta “dizin oluşturucu kullanılarak yeni bir öge ekleyebilir <strong>veya</strong> mevcut bir ögenin değeri <strong>güncellenebilir</strong>” diye açıklanır ve hemen altında örnek olarak <code>sozluk[\"anahtar\"] = \"yeni değer\";</code> verilir. <br/></li><br/></ol><br/>Dolayısıyla <code>Add(1,\"Elma\")</code> satırı anahtarı ekledikten sonra, <code>sozluk[1] = \"Armut\";</code> satırı <strong>1</strong> anahtarının değerini “Elma”dan <strong>“Armut”</strong>’a çevirir. <code><em>Console.WriteLine(sozluk[</em>1]);</code> da <strong>Armut</strong> yazdırır."
  },
  {
    "id": "3845974",
    "unitNumber": 2,
    "text": "\"SortedDictionary\" ile \"Dictionary\" arasındaki en belirgin fark aşağıdakilerden <strong>hangisidir</strong>?",
    "correctAnswer": "C",
    "options": {
      "A": "SortedDictionary boxing/unboxing yapar",
      "B": "Dictionary O(log n) karmaşıklığa sahiptir",
      "C": "SortedDictionary anahtarları sıralı tutar",
      "D": "Dictionary değerleri sıralı tutar",
      "E": "SortedDictionary null anahtar kabul eder"
    },
    "explanation": "<ul><br/><li><br/><strong>Dictionary</strong><br/><ul><br/><li><br/>Anahtar-değer çiftlerini <strong>sırasız</strong> olarak saklar.<br/></li><br/><li><br/>Ekleme, arama ve silme işlemlerinde <strong>ortalama O(1)</strong> zaman karmaşıklığı vardır.<br/></li><br/><li><br/>Anahtarların eklenme sırasını veya alfabetik sırasını <strong>korumaz</strong>.<br/></li><br/></ul><br/></li><br/><li><br/><strong>SortedDictionary</strong><br/><ul><br/><li><br/>Anahtar-değer çiftlerini <strong>her zaman anahtara göre sıralı</strong> tutar.<br/></li><br/><li><br/>Arama, ekleme ve silme işlemleri <strong>O(log n)</strong> zaman karmaşıklığına sahiptir çünkü altında <strong>dengeli ağaç yapısı</strong> (Red-Black Tree) kullanır.<br/></li><br/><li><br/>Sıralı erişim gerektiren durumlarda tercih edilir.<br/></li><br/></ul><br/></li><br/></ul><br/><strong>SortedDictionary boxing/unboxing yapar:</strong> Yanlış. Hem Dictionary hem de SortedDictionary doğru veri türü kullanıldığında boxing/unboxing yapmaz<br/><strong>Dictionary O(log n) karmaşıklığa sahiptir:</strong> Yanlış. Dictionary genellikle O(1) karmaşıklığa sahiptir.<br/><strong>Dictionary değerleri sıralı tutar:</strong> Yanlış. Dictionary ve SortedDictionary sadece <strong>anahtarlar</strong> üzerinde çalışır, değerler sıralanmaz.<br/><strong>SortedDictionary null anahtar kabul eder:</strong> Yanlış. Ne Dictionary ne de SortedDictionary null anahtar kabul eder.<br/>Doğru cevap C seçeneğidir."
  },
  {
    "id": "3845979",
    "unitNumber": 2,
    "text": "C#’ta bir kümeden, başka bir kümede bulunan elemanları çıkarmak için hangi HashSet metodu <strong>kullanılır</strong>?",
    "correctAnswer": "C",
    "options": {
      "A": "UnionWith",
      "B": "IntersectWith",
      "C": "ExceptWith",
      "D": "SymmetricExceptWith",
      "E": "IsSubsetOf"
    },
    "explanation": "İki küme (<strong>HashSet</strong>) var.<br/>Bir kümeden, diğerinde <strong>ortak olan elemanları çıkarmak</strong> istiyoruz.<br/>Bu işlem matematikte <strong>fark işlemi</strong> (<strong>A \\ B</strong>) olarak bilinir.<br/><strong>UnionWith:</strong> iki kümenin birleşimini oluşturur.<br/><ul><br/><li><strong>IntersectWith:</strong> iki kümenin ortak elemanlarını tutar.</li><br/><li><strong>ExceptWith:</strong> mevcut kümeden, verilen kümede bulunan elemanları çıkarır; bu sayede başka bir kümede bulunan elemanlar çıkarılmış olur.</li><br/><li><strong>SymmetricExceptWith:</strong> iki kümede olanlar dışındaki elemanları tutar (eşit fark).</li><br/><li><strong>IsSubsetOf:</strong> bir kümenin başka bir kümede tüm elemanlarının bulunup bulunmadığını kontrol eder.<br/>Bu nedenle, “bir kümeden, başka bir kümede bulunan elemanları çıkarmak” için kullanılan yöntem ExceptWith’tır.</li><br/></ul><br/>Doğru cevap C seçeneğidir."
  },
  {
    "id": "3845993",
    "unitNumber": 2,
    "text": "ArrayList ile List<t> arasındaki temel fark aşağıdakilerden hangisidir?</t>",
    "correctAnswer": "B",
    "options": {
      "A": "ArrayList generic yapıdadır, List<t> değildir</t>",
      "B": "List<t> tür güvenliği sağlar, ArrayList sağlamaz</t>",
      "C": "ArrayList sadece int saklayabilir",
      "D": "List<t> boxing/unboxing yapar</t>",
      "E": "ArrayList O(1) ekleme yapamaz"
    },
    "explanation": "Doğru cevap: B) List<t> tür güvenliği sağlar, ArrayList sağlamaz</t><br/>Gerekçe:<br/><ul> <li>List<t> generic bir koleksiyondur ve belirli bir türe sahip olması garantisini verir. Yani derleme zamanında tip güvenliği sağlanır.</t></li> <li>ArrayList ise eski, generic olmayan bir koleksiyon olduğu için içine hangi türde eleman eklendiği belirsizdir. Bu nedenle çalışma zamanında tip kontrolü yapılır ve tür güvenliği yoktur; her eleman için casting gerekir.<br/>Diğer seçenekler:</li> <li>A) Yanlış: ArrayList generic değildir; List<t> ise generic’tir.</t></li> <li>C) Yanlış: ArrayList herhangi bir tipte nesneleri saklayabilir (object olarak). Sadece int ile sınırlı değildir.</li> <li>D) Yanlış: Boxing/unboxing durumu List<t> için de geçerli olabilir çünkü T, değer tipi ise boxing gerekebilir; ama ana fark türe dayalı güvenliktir.</t></li> <li>E) Yanlış: ArrayList’in ekleme performansı O(1) amortize olabilir; genel olarak da O(1) ortalama ekleme sağlar. Bu, sorunun doğrudan farkını belirtmez.</li> </ul>"
  },
  {
    "id": "3845994",
    "unitNumber": 2,
    "text": "Aşağıdaki kodun çıktısı <strong>nedir</strong>?<br/><em>var sayilar = new List<int>() { 1, 2, 3 };</int></em><br/><em>sayilar.Remove(2);</em><br/><em>Console.WriteLine(sayilar.Contains(2));</em>",
    "correctAnswer": "A",
    "options": {
      "A": "False",
      "B": "True",
      "C": "null",
      "D": "Hata verir",
      "E": "0"
    },
    "explanation": "<ul><br/><li>Başlangıçta sayilar listesi [1, 2, 3].</li><br/><li>sayilar.Remove(2) çağrısı, listeden değeri 2 olan elemanı kaldırır; sonuç [1, 3].</li><br/><li>Ardından sayilar.Contains(2) çağrısı, listede değeri 2 olan eleman olup olmadığını kontrol eder; bulunmaz.</li><br/><li>Bu nedenle çıktı False olur.</li><br/></ul>"
  },
  {
    "id": "3940863",
    "unitNumber": 2,
    "text": "Aşağıdaki ifadelerden hangisi kitapta anlatılan <strong>Hashtable</strong> ve <strong>Dictionary</strong> veri yapıları arasındaki farkı <strong>doğru</strong> açıklar?",
    "correctAnswer": "C",
    "options": {
      "A": "Hashtable yalnızca string türünde anahtar kabul eder, Dictionary ise tüm türleri kabul eder.",
      "B": "Hashtable, anahtar ve değer türlerini belirtmeyi gerektirir; Dictionary ise belirtmez.",
      "C": "Hashtable’da anahtar ve değerler <em>object</em> türünde tutulur, bu nedenle boxing/unboxing oluşabilir; Dictionary ise <em>jenerik bir yapı</em> olduğu için türler önceden belirlenir ve boxing/unboxing gerektirmez.",
      "D": "Dictionary, hash tabanlı değildir; Hashtable ise hash tabanlıdır.",
      "E": "Hashtable, değerleri sıralı tutar; Dictionary tutmaz."
    },
    "explanation": "A) <strong>Hashtable yalnızca string türünde anahtar kabul eder, Dictionary ise tüm türleri kabul eder.</strong> <ul> <li><strong>Yanlış:</strong> Hashtable, anahtar olarak yalnızca string kabul etmez; object türünde herhangi bir veri türünü anahtar olarak kullanmanıza olanak tanır. Dictionary ise, tür parametreleri ile daha fazla esneklik sağlar, ancak her iki yapı da çok çeşitli veri türlerini anahtar olarak kullanabilir.</li> </ul> B) <strong>Hashtable, anahtar ve değer türlerini belirtmeyi gerektirir; Dictionary ise belirtmez.</strong> <ul> <li><strong>Yanlış:</strong> Hashtable kullanırken anahtar ve değerlerin türleri kesin olarak belirtilmek zorunda değildir çünkü bu türler object türündedir. Dictionary ise tam tersine jenerik bir yapı olduğundan anahtar ve değer türlerinin belirtilmesi gerekmektedir. Yani, bu ifade tersine doğrudur.</li> </ul> C) <strong>Hashtable’da anahtar ve değerler object türünde tutulur, bu nedenle boxing/unboxing oluşabilir; Dictionary ise jenerik bir yapı olduğu için türler önceden belirlenir ve boxing/unboxing gerektirmez.</strong> <ul> <li><strong>Doğru:</strong> Hashtable anahtar ve değerleri object türünde sakladığı için farklı türlerdeki veriler için boxing ve unboxing işlemleri gerektirebilir. Dictionary ise jenerik yapısı sayesinde türün önceden belirlenmesine olanak tanır ve dolayısıyla bu tür işlemlere ihtiyaç yoktur.</li> </ul> D) <strong>Dictionary, hash tabanlı değildir; Hashtable ise hash tabanlıdır.</strong> <ul> <li><strong>Yanlış:</strong> Her iki veri yapısı da hash tabanlıdır. Hashtable, tarihsel olarak daha eski bir yapı olmasına rağmen, Dictionary de hash tabanlı bir koleksiyon olarak çalışır ve anahtar-değer çiftlerini hızlı bir şekilde erişebilmek için hash fonksiyonları kullanır.</li> </ul> E) <strong>Hashtable, değerleri sıralı tutar; Dictionary tutmaz.</strong> <ul> <li><strong>Yanlış:</strong> Ne Hashtable ne de Dictionary, öğelerini sıralı tutmaz. Her ikisi de anahtarları üzerinden hızlı erişim sağlamak için tasarlanmış hash tabanlı yapılardır. Eğer sıralı veri yapısına ihtiyacınız varsa, List veya SortedDictionary gibi diğer veri yapıları kullanmalısınız.</li> </ul>"
  },
  {
    "id": "3623985",
    "unitNumber": 3,
    "text": "Push işlemi hangi amaçla kullanılır?",
    "correctAnswer": "A",
    "options": {
      "A": "Yığınlara öge eklemek için kullanılır.",
      "B": "Yığından öge çıkartmak için kullanılır.",
      "C": "Ögeyi yığından kaldırmadan sadece görüntülemek için kullanılır.",
      "D": "Yığını oluşturmak için kullanılır.",
      "E": "Yığını sıralamak için kullanılır."
    },
    "explanation": "Yığın için standart model, bir restorandaki tabak yığınıdır. Yığındaki tabaklar her zaman üstten çıka- rılır. Yığına ekleme yapılacaksa da üstten ekleme yapılabilir. Yığın, Son Giren İlk Çıkar (LIFO - Last In First Out) veri yapısı olarak bilinir. <br/>Bir yığındaki iki temel işlem, yığına ögelerin eklenmesi ve ögelerin yığından çıkarılmasıdır. Yığınlara öge eklemek için Push (itme) işlemi kullanılır. Yığından ögeyi çıkarTmak için ise Pop(Çekme) işlemi kullanılabilir. <br/>Bir yığın üzerinde gerçekleştirilecek diğer birincil işlem ise en üstteki ögeyi görüntülemektir. Pop işlemi en üstteki ögeyi döndürürken ögeyi yığından kaldırır. Ögeyi yığından kaldırmadan sadece görüntülemek için kullanılan işlem ise C# dilinde Peek(Tepe) olarak adlandırılır."
  },
  {
    "id": "3623986",
    "unitNumber": 3,
    "text": "Ögeyi yığından kaldırmadan sadece görüntülemek için C# dilinde ne kullanılır?",
    "correctAnswer": "A",
    "options": {
      "A": "Peek",
      "B": "Pop",
      "C": "Push",
      "D": "Get",
      "E": "List"
    },
    "explanation": "Pop işlemi en üstteki ögeyi döndürürken ögeyi yığından kaldırır. Ögeyi yığından kaldırmadan sadece görüntülemek için kullanılan işlem ise C# dilinde Peek(Tepe) olarak adlandırılır. Diğer dillerde de Peek işlemine benzer operasyonlar (Top vs.) vardır."
  },
  {
    "id": "3623987",
    "unitNumber": 3,
    "text": "CopyTo yönteminin kullanıldığı işlem aşağıdakilerden hangisidir?",
    "correctAnswer": "A",
    "options": {
      "A": "Bir yığının içeriğini tek boyutlu bir diziye kopyalamak için kullanılır.",
      "B": "En üstteki ögeyi yığından çıkarmak için kullanılır.",
      "C": "Ögeyi yığından çıkarmaksızın yığının tepesindeki ögenin değerine bakmak için kullanılır.",
      "D": "Yığındaki tüm elemanları kaldırıp öge sayısını sıfır olarak ayarlamak için kullanılır.",
      "E": "Bir ögenin, yığın içerisinde bulunup bulunmadığını kontrol etmek için kullanılır."
    },
    "explanation": "CopyTo yöntemi, bir yığının içeriğini tek boyutlu bir diziye kopyalamak için kullanılır. Hedef dizi, tüm yığın nesnelerinin veri türüyle aynı olmalıdır. CopyTo yöntemi, hedef dizi ve başlangıç indeksini gösteren iki parametre alır. Yığının ögeleri LIFO şeklinde kopyalanır. Yığına son eklenen öge, dizinin ilk elemanı olacaktır."
  },
  {
    "id": "3623988",
    "unitNumber": 3,
    "text": "Stack isimli yeni bir yığın oluşturduğumuzda sırasıyla aşağıdaki işlemler sonrasında yığın görüntüsü ne olacaktır?<br/>mystack.push(1);<br/>mystack.push(2);<br/>mystack.push(3);<br/>mystack.push(4);<br/>mystack.pop();<br/>mystack.pop();<br/>mystack.push(5);",
    "correctAnswer": "A",
    "options": {
      "A": "5 2 1",
      "B": "1 2 3 4 5",
      "C": "4 3 2 1",
      "D": "5 4",
      "E": "5"
    },
    "explanation": "Çözümdeki açıklamalara göre soru kökünde verilen sırada push ve pop işlemleri sonucunda yığın \" 5 2 1\" olacaktır.<br/>Bir yığındaki iki temel işlem, yığına ögelerin eklenmesi ve ögelerin yığından çıkarılmasıdır. Yığınlara öge eklemek için Push (itme) işlemi kullanılır. Yığından ögeyi çıkarTmak için ise Pop(Çekme) işlemi kullanılabilir. Resim 3.1’de yığın üzerinde yapılan Push ve Pop işlemleri gösterilmiştir.<br/><img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/26f605f0945d68d4fa82e87c132276b6.png\" alt=\"\" width=\"441\" height=\"207\">"
  },
  {
    "id": "3623989",
    "unitNumber": 3,
    "text": "yenikuyruk isimli yeni bir kuyruk yapısı oluşturduğumuzda sırasıyla aşağıdaki işlemler sonrasında kuyruk görüntüsü ne olacaktır?<br/>yenikuyruk.enqueue(1);<br/>yenikuyruk.enqueue(2);<br/>yenikuyruk.enqueue(3);<br/>yenikuyruk.enqueue(4);<br/>yenikuyruk.dequeue();<br/>yenikuyruk.enqueue(5);<br/>yenikuyruk.dequeue();",
    "correctAnswer": "A",
    "options": {
      "A": "3 4 5",
      "B": "5",
      "C": "1 2 3 4",
      "D": "1 2 3 4 5",
      "E": "1 5"
    },
    "explanation": "Kuyruk yapıları için üç temel işlem vardır. Bu işlemlerden ikisi listeye eleman eklemek ve listeden ele- man kaldırmak için kullanılır. Kuyruğa yeni öge ekleme işlemi Enqueue (Sıraya Alma) olarak adlandırılır. Kuyruktan öge çıkarma işlemi ise Dequeue (Sıradan Çıkarma) olarak adlandırılır. Enqueue işlemi kuyruk sırasının sonuna bir öge ekler. Dequeue işlemi sıranın önündeki ögeyi kaldırır. Resim 3.2’de Enqueue ve Dequeue işlemleri görsel üzerinde anlatılmıştır.<br/><img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/f4808ead40f477f6dcfd611cd572c568.png\" alt=\"\" width=\"409\" height=\"65\"><br/>Buna göre doğru seçenek A'dır.<br/>Doğrusal veri yapılarının diğer önemli yapısı Kuyruk (Queue) yapılarıdır. Kuyruk; verilerin liste olarak tutulduğu, yeni gelen verinin listenin arkasına eklendiği, kaldırma işleminin ise listenin önündeki veriye uygulandığı bir yapıdır yani her zaman ilk önce giren veri ilk çıkar (FIFO- First In First Out). Kuyruk yapısına, banka sırası örnek olarak verilebilir. Bankada sırası gelen müşteri işini bitirir ve sıradakinin işlemi başlar. Yeni gelen müşteriler kuyruğun arkasından sıraya eklenir.<br/>Kuyruklar, ögeleri oluştukları sırayla depolamak için kullanılır. Bir işletim sistemine veya yazdırma biriktiricisine gönderilen işlemleri sipariş etmek için kullanılabilir."
  },
  {
    "id": "3623990",
    "unitNumber": 3,
    "text": "Queue nesnesi kullanılarak yeni bir kuyruk oluşturulduğunda nesne varsayılan olarak kaç eleman kapasiteli bir kuyruk oluşur?",
    "correctAnswer": "B",
    "options": {
      "A": "16",
      "B": "32",
      "C": "64",
      "D": "128",
      "E": "100"
    },
    "explanation": "Kuyruk yapısında kullanılan temel yöntemleri önceki örnekte inceledik. Bu yöntemleri inceleyebilmek için bir problemi Kuyruk yapısı kullanarak çözen bir program yazmak daha detaylı incelememize olanak sağlayacaktır.<br/>C# dilinde, Yığın yapısında olduğu gibi, kuyruk yapısını oluşturmak içinde dil ile birlikte gelen nesneler kullanılabilir. Queue nesnesi kullanılarak yeni bir kuyruk oluşturulabilir. Nesne varsayılan olarak 32 eleman kapasiteli bir kuyruk oluşturur. Kuyruğun kapasitesi doldukça bir sonraki kapasite iki katı olacak şekilde art- tırılır. Yani varsayılan değer (32 öge) ile oluşturulan kuyruğun kapasitesi dolduğunda 64 eleman kapasitesine çıkarılacaktır. Buradaki kapasiteyi her defasında iki katına çıkaran sayı, büyüme faktörü olarak adlandırılır."
  },
  {
    "id": "3623991",
    "unitNumber": 3,
    "text": "500 öge kapasiteli ve kapasitesi dolduktan sonra 5 katına çıkacak olan kuyruk tanımlaması aşağıdakilerden hangisidir?",
    "correctAnswer": "B",
    "options": {
      "A": "Queue kuyruk = new Queue(100, 500);",
      "B": "Queue kuyruk = new Queue(500, 5);",
      "C": "Queue kuyruk = new Queue(500, 2500);",
      "D": "Queue kuyruk = new Queue(500, 5+);",
      "E": "Queue kuyruk = new Queue(500, 500);"
    },
    "explanation": "Çözüm kısmındaki açıklamaya göre soru kökündeki 500 öge kapasiteli ve kapasitesi dolduktan sonra 5 katına çıkacak olan kuyruk tanımlaması B seçeneğindeki gibidir.<br/>Kuyruk kapasitesini belirtirken büyüme faktörünü de değiştirebilirsiniz. Constructura iletilen ikinci değer büyüme faktörünün belirtildiği sayıdır. Aşağıdaki kod bloğunda belirtilen 3 rakamından dolayı kuyruğun kapasitesi dolduktan sonra yeni boyut 300 olacaktır.<br/>Queue kuyruk = new Queue(100, 3);"
  },
  {
    "id": "3623992",
    "unitNumber": 3,
    "text": "Verilerin liste olarak tutulduğu, yeni gelen verinin listenin arkasına eklendiği, kaldırma işleminin ise listenin önündeki veriye uygulandığı bir yapı hangisidir?",
    "correctAnswer": "B",
    "options": {
      "A": "Yığın",
      "B": "Kuyruk",
      "C": "Stack",
      "D": "Dizi",
      "E": "Liste"
    },
    "explanation": "Doğrusal veri yapılarının diğer önemli yapısı Kuyruk (Queue) yapılarıdır. Kuyruk; verilerin liste olarak tutulduğu, yeni gelen verinin listenin arkasına eklendiği, kaldırma işleminin ise listenin önündeki veriye uygulandığı bir yapıdır yani her zaman ilk önce giren veri ilk çıkar (FIFO- First In First Out). Kuyruk yapısına, banka sırası örnek olarak verilebilir. Bankada sırası gelen müşteri işini bitirir ve sıradakinin işlemi başlar. Yeni gelen müşteriler kuyruğun arkasından sıraya eklenir.<br/>Kuyruklar, ögeleri oluştukları sırayla depolamak için kullanılır. Bir işletim sistemine veya yazdırma biriktiricisine gönderilen işlemleri sipariş etmek için kullanılabilir."
  },
  {
    "id": "3623993",
    "unitNumber": 3,
    "text": "Contains yöntemi hangi amaçla kullanılır?",
    "correctAnswer": "A",
    "options": {
      "A": "Bir ögenin, yığın içerisinde bulunup bulunmadığını kontrol etmek için kullanılır.",
      "B": "Bir yığının içeriğini tek boyutlu bir diziye kopyalamak için kullanılır.",
      "C": "Bir yığının içeriğini silmek için kullanılır.",
      "D": "Bir yığından öge çıkartmak amacıyla kullanılır.",
      "E": "Bir yığına öge eklemek amacıyla kullanılır."
    },
    "explanation": "Aşağıdaki kod bloğunda Contains yönteminin kullanımını inceleyebilirsiniz. Kod 3.10<br/>if (myStack.Contains(“ “))<br/>IslemiDurdur();<br/>else<br/>IslemeDevamEt();<br/>Bir ögenin, yığın içerisinde bulunup bulunmadığını kontrol etmek için Contains yöntemi kullanılabi- lir. Contains yöntemi öge yığının içeriğinde mevcut ise True değer, mevcut değilse False değer döndürür.<br/>Aşağıdaki kod bloğunda Contains yönteminin kullanımını inceleyebilirsiniz. Kod 3.10<br/>if (myStack.Contains(“ “)) IslemiDurdur(); else<br/>IslemeDevamEt();"
  },
  {
    "id": "3624142",
    "unitNumber": 3,
    "text": "Yığın yapısı ile ilgili aşağıda verilen bilgilerden hangisi hatalıdır?",
    "correctAnswer": "C",
    "options": {
      "A": "Tek taraflı veri giriş ve çıkışına izin verir.",
      "B": "Verileri sıralı olarak tutar.",
      "C": "İlk Giren ilk Çıkar (FIFO - First In First Out) veri yapısı olarak bilinir.",
      "D": "En sık kullanılan veri yapılarından biridir ve anlaşılması kolaydır.",
      "E": "Standart model, bir restorandaki tabak yığını olarak düşünülebilir."
    },
    "explanation": "Yığına ekleme yapılacaksa da üstten ekleme yapılabilir. Yığın, Son Giren İlk Çıkar (LIFO - Last In First Out) veri yapısı olarak bilinir. Bu nedenle C seçeneğindeki bilgi hatalıdır.<br/>Yığın yapısı, programlama dillerinde en sık kullanılan veri yapılarından biridir ve anlaşılması kolaydır. Tek taraflı veri giriş ve çıkışına izin veren yığın yapısı, verileri sıralı olarak tutar. Yığın; yalnızca yığının tepesi olarak adlandırılan, listenin sonundan erişilebilen ögelerin bir listesi olarak tanımlanabilir. Yığın için standart model, bir restorandaki tabak yığınıdır. Yığındaki tabaklar her zaman üstten çıkarılır. Yığına ekleme yapılacaksa da üstten ekleme yapılabilir. Yığın, Son Giren İlk Çıkar (LIFO - Last In First Out) veri yapısı olarak bilinir."
  },
  {
    "id": "3624143",
    "unitNumber": 3,
    "text": "Yığın yapısında Pop işlemi aşağıdakilerden hangi görevi üstlenir?",
    "correctAnswer": "A",
    "options": {
      "A": "En üstteki ögeyi döndürürken ögeyi yığından kaldırır.",
      "B": "Seçilen ögeyi yığından kaldırmadan sadece görüntüler.",
      "C": "Yığının en başına yeni bir öge ekler.",
      "D": "Yığının en sonundan öge kaldırır.",
      "E": "Yığının verilen indisine öge ekler."
    },
    "explanation": "Bir yığın üzerinde gerçekleştirilecek diğer birincil işlem ise en üstteki ögeyi görüntülemektir. Pop işlemi en üstteki ögeyi döndürürken ögeyi yığından kaldırır. Ögeyi yığından kaldırmadan sadece görüntülemek için kullanılan işlem ise C# dilinde Peek(Tepe) olarak adlandırılır."
  },
  {
    "id": "3624144",
    "unitNumber": 3,
    "text": "String[] ulkeler= new string[] {\"Almanya\", \"Çin\", \"Fransa\", \"İtalya\", \"Türkiye\"};<br/>Stack ulkeYigin= new Stack(ulkeler);<br/>Yukarıdaki kod parçası ile oluşan yığına Pop işlemi uygulandığında aşağıdakilerden hangisi gerçekleşir?",
    "correctAnswer": "A",
    "options": {
      "A": "İlk olarak Türkiye ögesi yığından çıkarılacaktır.",
      "B": "İlk olarak Almanya ögesi yığından çıkarılacaktır.",
      "C": "Almanya ve ardından Çin ögesi birlikte yığından çıkarılacaktır.",
      "D": "Mevcut ögelerin tümü tekrar yığına eklenir.",
      "E": "Tüm ögeler yığından çıkarılacaktır."
    },
    "explanation": "Soru kökündeki yığına Pop işlemi uygulandığında ilk olarak Türkiye ögesi yığından çıkarılacaktır.<br/>Constructora iletilen dizinin son elemanı, yığınında son elemanı yani tepesidir. Yığına Pop işlemi uygulandığında ilk olarak Türkiye ögesi yığından çıkarılacaktır."
  },
  {
    "id": "3624145",
    "unitNumber": 3,
    "text": "Bir ögenin, yığın içerisinde bulunup bulunmadığını kontrol etmek için hangi yöntem kullanılır?",
    "correctAnswer": "E",
    "options": {
      "A": "Pop",
      "B": "Push",
      "C": "Peek",
      "D": "Clear",
      "E": "Contains"
    },
    "explanation": "Aşağıdaki kod bloğunda Contains yönteminin kullanımını inceleyebilirsiniz.<br/>if (myStack.Contains(\" \"))<br/>IslemiDurdur();<br/>else<br/>IslemeDevamEt();<br/>Bir ögenin, yığın içerisinde bulunup bulunmadığını kontrol etmek için Contains yöntemi kullanılabilir. Contains yöntemi öge yığının içeriğinde mevcut ise True değer, mevcut değilse False değer döndürür."
  },
  {
    "id": "3624146",
    "unitNumber": 3,
    "text": "CopyTo yöntemi ile ilgili aşağıdaki bilgilerden hangisi hatalıdır?",
    "correctAnswer": "D",
    "options": {
      "A": "BBir yığının içeriğini tek boyutlu bir diziye kopyalamak için kullanılır.",
      "B": "Hedef dizi, tüm yığın nesnelerinin veri türüyle aynı olmalıdır.",
      "C": "Hedef dizi ve başlangıç indeksini gösteren iki parametre alır.",
      "D": "Yığının ögeleri FIFO şeklinde kopyalanır",
      "E": "Yığına son eklenen öge, dizinin ilk elemanı olacaktır."
    },
    "explanation": "Yığının ögeleri LIFO şeklinde kopyalanır. Bu nedenle D seçeneği hatalıdır.<br/>CopyTo yöntemi, bir yığının içeriğini tek boyutlu bir diziye kopyalamak için kullanılır. Hedef dizi, tüm yığın nesnelerinin veri türüyle aynı olmalıdır. CopyTo yöntemi, hedef dizi ve başlangıç indeksini gösteren iki parametre alır. Yığının ögeleri LIFO şeklinde kopyalanır. Yığına son eklenen öge, dizinin ilk elemanı olacaktır."
  },
  {
    "id": "3624147",
    "unitNumber": 3,
    "text": "I. Külahta alınmış dondurma topları<br/>II. Bankada sırada duran müşteriler<br/>III. Bilgisayarda Ctrl+Z(geri alma) işlemi <br/>IV. Restoranda üst üste duran tabaklar<br/>Yukarıdakilerden hangisi veya hangileri kuyruk yapısına örnektir?",
    "correctAnswer": "A",
    "options": {
      "A": "Yalnız II",
      "B": "I-III-IV",
      "C": "I-II",
      "D": "III-IV",
      "E": "I-II-III-IV"
    },
    "explanation": "Yığın is Son Giren İlk Çıkar (LIFO - Last In First Out) mantığı ile çalışır. Bu nedenle I. Külahta alınmış dondurma topları, III. Bilgisayarda Ctrl+Z(geri alma) işlemi ve IV. Restoranda üst üste duran tabaklar yığına örnektir.<br/>Doğrusal veri yapılarının diğer önemli yapısı Kuyruk (Queue) yapılarıdır. Kuyruk; verilerin liste olarak tutulduğu, yeni gelen verinin listenin arkasına eklendiği, kaldırma işleminin ise listenin önündeki veriye uygulandığı bir yapıdır yani her zaman ilk önce giren veri ilk çıkar (FIFO- First In First Out). Kuyruk yapısına, banka sırası örnek olarak verilebilir. Bankada sırası gelen müşteri işini bitirir ve sıradakinin işlemi başlar. Yeni gelen müşteriler kuyruğun arkasından sıraya eklenir."
  },
  {
    "id": "3624148",
    "unitNumber": 3,
    "text": "Queue kuyruk = new Queue(100, 4);<br/>Yukarıdaki kod bloğu ile ilgili aşağıda verilen bilgilerden hangisi doğrudur?",
    "correctAnswer": "A",
    "options": {
      "A": "Kuyruk kapasitesi dolduktan sonra yeni boyut 400 olacaktır.",
      "B": "Varsayılan olarak 32 eleman kapasiteli bir kuyruk oluşturulur.",
      "C": "Kuyruğun kapasitesi dolduğunda 64 eleman kapasitesine çıkarılacaktır.",
      "D": "Kuyruk kapasitesi iki katı olacak şekilde arttırılacaktır.",
      "E": "Kuyruk kapasitesi 3 kez arttılabilecektir."
    },
    "explanation": "Soru kökündeki kod bloğunda belirtilen 4 rakamından dolayı kuyruğun kapasitesi dolduktan sonra yeni boyut 400 olacaktır.<br/>Queue kuyruk = new Queue(100, 4);<br/>C# dilinde, Yığın yapısında olduğu gibi, kuyruk yapısını oluşturmak içinde dil ile birlikte gelen nesneler kullanılabilir. Queue nesnesi kullanılarak yeni bir kuyruk oluşturulabilir. Nesne varsayılan olarak 32 eleman kapasiteli bir kuyruk oluşturur. Kuyruğun kapasitesi doldukça bir sonraki kapasite iki katı olacak şekilde arttırılır. Yani varsayılan değer (32 öge) ile oluşturulan kuyruğun kapasitesi dolduğunda 64 eleman kapasitesine çıkarılacaktır. Buradaki kapasiteyi her defasında iki katına çıkaran sayı, büyüme faktörü olarak adlandırılır.<br/>Kuyruk kapasitesini belirtirken büyüme faktörünü de değiştirebilirsiniz. Constructura iletilen ikinci değer büyüme faktörünün belirtildiği sayıdır. Aşağıdaki kod bloğunda belirtilen 3 rakamından dolayı kuyruğun kapasitesi dolduktan sonra yeni boyut 300 olacaktır.<br/>Queue kuyruk = new Queue(100, 3);"
  },
  {
    "id": "3624149",
    "unitNumber": 3,
    "text": "Aşağıdakilerden hangisi öncelikli bir kuyrukta çağrıldığında kuyruktaki ilk ögeyi kaldırır?",
    "correctAnswer": "A",
    "options": {
      "A": "Dequeue",
      "B": "Enqueue",
      "C": "Clearqueue",
      "D": "Peek",
      "E": "Count"
    },
    "explanation": "Dequeue yöntemi, çağrıldığında kuyruktaki ilk ögeyi kaldırır. Öncelik sırası uygulamak istenen Queue nesnesinde, önceliğe göre kuyruktan çıkarma işlemi yapmak için Dequeue işlemi devre dışı bırakılır. Queue nesnesinden programın ihtiyacına göre öncelikli kuyruk sınıfı üretilebilir."
  },
  {
    "id": "3624150",
    "unitNumber": 3,
    "text": "Kuyruğa yeni öge ekleme işlemi için hangi işlem gereklidir?",
    "correctAnswer": "A",
    "options": {
      "A": "Enqueue",
      "B": "Dequeue",
      "C": "Peek",
      "D": "Count",
      "E": "Push"
    },
    "explanation": "Kuyruk yapıları için üç temel işlem vardır. Bu işlemlerden ikisi listeye eleman eklemek ve listeden eleman kaldırmak için kullanılır. Kuyruğa yeni öge ekleme işlemi Enqueue (Sıraya Alma) olarak adlandırılır. Kuyruktan öge çıkarma işlemi ise Dequeue (Sıradan Çıkarma) olarak adlandırılır. Enqueue işlemi kuyruk sırasının sonuna bir öge ekler."
  },
  {
    "id": "3624151",
    "unitNumber": 3,
    "text": "Queue nesnesi kullanılarak yeni bir kuyruk oluşturulduğunda varsayılan eleman kapasitesi kaç olacaktır?",
    "correctAnswer": "B",
    "options": {
      "A": "16",
      "B": "32",
      "C": "64",
      "D": "100",
      "E": "300"
    },
    "explanation": "C# dilinde, Yığın yapısında olduğu gibi, kuyruk yapısını oluşturmak içinde dil ile birlikte gelen nesneler kullanılabilir. Queue nesnesi kullanılarak yeni bir kuyruk oluşturulabilir. Nesne varsayılan olarak 32 eleman kapasiteli bir kuyruk oluşturur. Kuyruğun kapasitesi doldukça bir sonraki kapasite iki katı olacak şekilde arttırılır. Yani varsayılan değer (32 öge) ile oluşturulan kuyruğun kapasitesi dolduğunda 64 eleman kapasitesine çıkarılacaktır. Buradaki kapasiteyi her defasında iki katına çıkaran sayı, büyüme faktörü olarak adlandırılır."
  },
  {
    "id": "3624159",
    "unitNumber": 3,
    "text": "Aşağıdakilerden hangisi yığın yapısının özelliklerinden biridir?",
    "correctAnswer": "A",
    "options": {
      "A": "Veriyi sıralı tutma",
      "B": "Çift taraflı giriş ve çıkışı mümkün kılma",
      "C": "Az tercih edilme",
      "D": "Anlaşılırlığı nispeten düşük olma",
      "E": "İlk giren ilk çıkar prensibini kullanma"
    },
    "explanation": "Yığın yapısı, programlama dillerinde en sık kullanılan veri yapılarından biridir ve anlaşılması kolaydır. Tek taraflı veri giriş ve çıkışına izin veren yığın yapısı,<strong> verileri sıralı olarak tutar.</strong> Yığın; yalnızca yığının tepesi olarak adlandırılan, listenin sonundan erişilebilen ögelerin bir listesi olarak tanımlanabilir.<br/>Yığın için standart model, bir restorandaki tabak yığınıdır. Yığındaki tabaklar her zaman üstten çıkarılır. Yığına ekleme yapılacaksa da üstten ekleme yapılabilir. Yığın, Son Giren İlk Çıkar (LIFO - Last In First Out) veri yapısı olarak bilinir."
  },
  {
    "id": "3624160",
    "unitNumber": 3,
    "text": "Yığınlara öge eklemek ve çıkarmak için yapılan işlemlere sırasıyla ne ad verilir?",
    "correctAnswer": "A",
    "options": {
      "A": "İtme ve çekme",
      "B": "Çekme ve bekleme",
      "C": "İlerletme ve işleme",
      "D": "İşleme ve sunma",
      "E": "İşleme ve itme"
    },
    "explanation": "Bir yığındaki iki temel işlem, yığına ögelerin eklenmesi ve ögelerin yığından çıkarılmasıdır. Yığınlara öge eklemek için Push (itme) işlemi kullanılır. Yığından ögeyi çıkartmak için ise Pop (Çekme) işlemi kullanılabilir."
  },
  {
    "id": "3624161",
    "unitNumber": 3,
    "text": "C dilinde ögeyi yığından kaldırmadan sadece görüntülemek için kullanılan işleme ne ad verilir?",
    "correctAnswer": "A",
    "options": {
      "A": "Tepe (peek)",
      "B": "İtme (push)",
      "C": "Çekme (pop)",
      "D": "Döndürme (for)",
      "E": "Temizleme (clear)"
    },
    "explanation": "Ögeyi yığından kaldırmadan sadece görüntülemek için kullanılan işlem ise C# dilinde <strong>Peek (Tepe)</strong> olarak adlandırılır."
  },
  {
    "id": "3624162",
    "unitNumber": 3,
    "text": "Yığındaki tüm elemanları kaldırıp, öge sayısını sıfır olarak ayarlayan yöntem aşağıdakilerden hangisidir?",
    "correctAnswer": "A",
    "options": {
      "A": "Clear",
      "B": "Contains",
      "C": "CopyTo",
      "D": "Peek",
      "E": "Stack"
    },
    "explanation": "<strong>Clear</strong> yöntemi; <strong>yığındaki tüm elemanları kaldırır,</strong> öge sayısını sıfır olarak ayarlar. Bir yığının gerçek kapasitesini inceleyemeyeceğimiz için Clear yönteminin bir yığının kapasitesini etkileyip etkilemediğini söylemek zordur. Bu nedenle kapasitenin başlangıçtaki varsayılan 10 öge boyutuna ayarlandığını varsaymak en iyisidir."
  },
  {
    "id": "3624163",
    "unitNumber": 3,
    "text": "Bir ögenin, yığın içerisinde bulunup bulunmadığını kontrol etmek için aşağıdaki yöntemlerden hangisi kullanılır?",
    "correctAnswer": "A",
    "options": {
      "A": "Contains",
      "B": "Peek",
      "C": "CopyTo",
      "D": "Stack",
      "E": "Lack"
    },
    "explanation": "Bir ögenin, yığın içerisinde bulunup bulunmadığını kontrol etmek için Contains yöntemi kullanılabilir."
  },
  {
    "id": "3624164",
    "unitNumber": 3,
    "text": "Verilerin liste olarak tutulduğu, yeni gelen verinin listenin arkasına eklendiği, kaldırma işleminin ise listenin önündeki veriye uygulandığı yapıya ne ad verilir?",
    "correctAnswer": "A",
    "options": {
      "A": "Kuyruk",
      "B": "Yığın",
      "C": "Push",
      "D": "Matris",
      "E": "Vektör"
    },
    "explanation": "Doğrusal veri yapılarının diğer önemli yapısı Kuyruk (Queue) yapılarıdır. Kuyruk; verilerin liste olarak tutulduğu, yeni gelen verinin listenin arkasına eklendiği, kaldırma işleminin ise listenin önündeki veriye uygulandığı bir yapıdır yani her zaman ilk önce giren veri ilk çıkar."
  },
  {
    "id": "3624165",
    "unitNumber": 3,
    "text": "Kuyruğa yeni öge ekleme işlemine ne ad verilir?",
    "correctAnswer": "A",
    "options": {
      "A": "Enqueue",
      "B": "Dequeue",
      "C": "Clearqueue",
      "D": "Consoleque",
      "E": "Containque"
    },
    "explanation": "Kuyruğa yeni öge ekleme işlemi Enqueue (Sıraya Alma) olarak adlandırılır. Kuyruktan öge çıkarma işlemi ise Dequeue (Sıradan Çıkarma) olarak adlandırılır."
  },
  {
    "id": "3624166",
    "unitNumber": 3,
    "text": "Kuyruktan öge çıkarma işlemine ne ad verilir?",
    "correctAnswer": "A",
    "options": {
      "A": "Dequeue",
      "B": "Enqueue",
      "C": "Clear",
      "D": "Contains",
      "E": "Peek"
    },
    "explanation": "Kuyruktan öge çıkarma işlemi ise Dequeue (Sıradan Çıkarma) olarak adlandırılır. Enqueue işlemi kuyruk sırasının sonuna bir öge ekler. Dequeue işlemi sıranın önündeki ögeyi kaldırır."
  },
  {
    "id": "3624167",
    "unitNumber": 3,
    "text": "Bir yığının içeriğini tek boyutlu bir diziye kopyalamak için aşağıdakilerden hangisi kullanılır?",
    "correctAnswer": "A",
    "options": {
      "A": "CopyTo",
      "B": "Contains",
      "C": "Peek",
      "D": "Clear",
      "E": "Dequeue"
    },
    "explanation": "CopyTo yöntemi, bir yığının içeriğini tek boyutlu bir diziye kopyalamak için kullanılır. Hedef dizi, tüm yığın nesnelerinin veri türüyle aynı olmalıdır. CopyTo yöntemi, hedef dizi ve başlangıç indeksini gösteren iki parametre alır."
  },
  {
    "id": "3624168",
    "unitNumber": 3,
    "text": "Aşağıdakilerden hangisi ögeyi yığından çıkarmak zorunda kalmadan yığının tepesindeki ögenin değerine bakmamızı sağlar?",
    "correctAnswer": "A",
    "options": {
      "A": "Peek",
      "B": "Clear",
      "C": "For",
      "D": "Contains",
      "E": "Push"
    },
    "explanation": "Peek yöntemi, ögeyi yığından çıkarmak zorunda kalmadan yığının tepesindeki ögenin değerine bakmamızı sağlar."
  },
  {
    "id": "3623994",
    "unitNumber": 4,
    "text": "Algoritma seçiminde, çalışılabilecek en büyük veri boyutu ve veri sayısı göz önüne alınmalıdır. Sıralama algoritmasında, ideal zaman karmaşıklığı değeri ................... olmalıdır.<br/>Yukarıdaki metinde boş bırakılan yere aşağıdakilerden hangisi gelmelidir?",
    "correctAnswer": "A",
    "options": {
      "A": "O(1)",
      "B": "arr[i]",
      "C": "CArray(10)",
      "D": "Random(100)",
      "E": "Q(1)"
    },
    "explanation": "Algoritma seçiminde, çalışılabilecek en büyük veri boyutu ve veri sayısı göz önüne alınmalıdır. Sıralama algoritmasında, ideal zaman karmaşıklığı değeri <strong>O(1)</strong> olmalıdır."
  },
  {
    "id": "3623995",
    "unitNumber": 4,
    "text": "Sıralama algoritmalarını incelemek için dizi elemanlarının rastgele üretilmiş verilerden oluşması ve<br/>algoritmaya ......................................... verilmesi gerekir.<br/>Yukarıdaki metinde boş bırakılan yere aşağıdakilerden hangisi gelmelidir?",
    "correctAnswer": "B",
    "options": {
      "A": "Ardışık olarak",
      "B": "Sırasız olarak",
      "C": "Parabolik olarak",
      "D": "Sıralı olarak",
      "E": "Yapılandırılmış olarak"
    },
    "explanation": "Sıralama algoritmalarını incelemek için dizi elemanlarının rastgele üretilmiş verilerden oluşması ve algoritmaya <strong>sırasız</strong> olarak verilmesi gerekir."
  },
  {
    "id": "3623996",
    "unitNumber": 4,
    "text": "Rastgele sayı dizisini oluşturmak için C# ile birlikte gelen ........................................ kullanılabilir.<br/>Yukarıdaki metinde boş bırakılan yere aşağıdakilerden hangisi gelmelidir?",
    "correctAnswer": "C",
    "options": {
      "A": "<em>Array</em> dizisi",
      "B": "<em>Public</em> sekmesi",
      "C": "<em>Random</em> sınıfı",
      "D": "<em>Parabolik</em> kümesi",
      "E": "<em>Fn</em> dizisi"
    },
    "explanation": "Rastgele sayı dizisini oluşturmak için C# ile birlikte gelen <strong><em>Random</em> sınıfı</strong> kullanılabilir."
  },
  {
    "id": "3623997",
    "unitNumber": 4,
    "text": "... Listedeki elemanları, ikili olarak yanındaki ile karşılaştırır ve sıralama yapılmak istenen yönde yer değiştirir. Artan sıralama yapılıyorsa büyük olan eleman sağ tarafa, küçük eleman sol tarafa alınarak yerleştirme yapılır...<br/>Yukarıdaki metinde açıklanmaya çalışılan, aşağıdaki hangi algoritma sıralamasıdır?",
    "correctAnswer": "D",
    "options": {
      "A": "Ekleme sıralama",
      "B": "Seçerek sıralama",
      "C": "Hızlı sıralama",
      "D": "Baloncuk sıralama",
      "E": "Rasgele sıralama"
    },
    "explanation": "<strong>Baloncuk Sıralama</strong> (Bubble Sort), listenin bir başından diğer başına kadar kayan bir baloncuk görüntüsü verdiği için bu şekilde adlandırılmıştır. Listedeki rastgele verilen elemanları artan sıra ile sıralarsak baloncuk sağa doğru kayacaktır. Azalan sıra ile sıralarsak baloncuk sola doğru kayacaktır. Listedeki elemanları, ikili olarak yanındaki ile karşılaştırır ve sıralama yapılmak istenen yönde yer değiştirir. Artan sıralama yapılıyorsa büyük olan eleman sağ tarafa, küçük eleman sol tarafa alınarak yerleştirme yapılır."
  },
  {
    "id": "3623998",
    "unitNumber": 4,
    "text": "Kod 4.7<br/>public void SecerekSiralama()<br/>{<br/>int min, temp;<br/>for (int dis = 0; dis &lt;= enBuyuk; dis++)<br/>{<br/>min = dis;<br/>for (int ic = dis + 1; ic &lt;= enBuyuk; ic++)<br/>if (arr[ic] &lt; arr[min])<br/>min = ic;<br/>temp = arr[dis];<br/>arr[dis] = arr[min];<br/>arr[min] = temp;<br/>}<br/>}<br/>Yukarıdaki kod bloğunda Seçerek Sıralama algoritması için C# kodu verilmiştir. Kod yapısı incelendiğinde iç içe iki adet for döngüsü vardır. Algoritmanın BigO notasyonu aşağıdakilerden hangisidir?",
    "correctAnswer": "E",
    "options": {
      "A": "+1",
      "B": "1",
      "C": "fx",
      "D": "x/y=n+1",
      "E": "n kare"
    },
    "explanation": "Algoritmanın BigO notasyonu <strong>n kare</strong>'dir."
  },
  {
    "id": "3623999",
    "unitNumber": 4,
    "text": "public void ..................................()<br/>{<br/>int ic, temp;<br/>for (int dis = 1; dis &lt;= enBuyuk; dis++)<br/>{<br/>temp = arr[dis];<br/>ic = dis;<br/>while (ic &gt; 0 &amp;&amp; arr[ic - 1] &gt;= temp)<br/>{<br/>arr[ic] = arr[ic - 1];<br/>ic -= 1;<br/>}<br/>arr[ic] = temp;<br/>}<br/>}<br/>Yukarıdaki C# kodu, aşağıdaki hangi sıralama algoritması için yazılmış olabilir?",
    "correctAnswer": "A",
    "options": {
      "A": "Ekleme sıralama",
      "B": "Hızlı sıralama",
      "C": "Döngüsel sıralama",
      "D": "Baloncuk sıralama",
      "E": "Seçerek sıralama"
    },
    "explanation": "Doğru yanıt, <strong>Ekleme sıralama</strong> olmalıdır."
  },
  {
    "id": "3624021",
    "unitNumber": 4,
    "text": ".................................... algoritması, iki adet döngü içerir. İlk döngü dizi elemanları üzerinde teker teker gezerken ikinci döngü sıradaki elemanı, önceki adımlarda düzenlenmiş olan elemanlar arasında olması gereken yere yerleştirir.<br/>Yukarıdaki metinde boş bırakılan yere aşağıdakilerden hangisi gelmelidir?",
    "correctAnswer": "B",
    "options": {
      "A": "Hızlı sıralama",
      "B": "Ekleme sıralama",
      "C": "Seçerek sıralama",
      "D": "Baloncuk sıralama",
      "E": "Paylaşmalı sıralama"
    },
    "explanation": "<strong>Ekleme sıralama</strong> algoritması, iki adet döngü içerir. İlk döngü dizi elemanları üzerinde teker teker gezerken ikinci döngü sıradaki elemanı, önceki adımlarda düzenlenmiş olan elemanlar arasında olması gereken yere yerleştirir."
  },
  {
    "id": "3624022",
    "unitNumber": 4,
    "text": "Dizi elemanlarından biri pivot değer olarak seçilerek algoritma başlatılır. Pivot, baştaki eleman seçilebileceği gibi rastgele bir elemanda seçilebilir. Pivotun dizi elemanlarına uygun seçilmesi algoritma başarısını etkileyecektir. Pivot seçildikten sonra dizinin diğer elemanları, pivottan küçük veya büyük olmasına göre iki gruba ayrılır. Sonraki adımda, bu iki grup kendi içlerinde tekrar bölünerek sıralanır. Grupların sıralaması için sıralama algoritması özyinelemeli (recursive) olarak çalıştırılır.<br/>Yukarıda çalışma sistemi anlatılan sıralama algoritması aşağıdakilerden hangisidir?",
    "correctAnswer": "C",
    "options": {
      "A": "Pivot sıralama algoritması",
      "B": "Ekleme sıralama algoritması",
      "C": "Hızlı sıralama algoritması",
      "D": "Baloncuk sıralama algoritması",
      "E": "Seçerek sıralama algoritması"
    },
    "explanation": "Metinde çalışma sistemi anlatılan sıralama algoritması, <strong>hızlı sıralama algoritması</strong>dır."
  },
  {
    "id": "3624023",
    "unitNumber": 4,
    "text": "Başlangıç Pivot=14<br/>96 15 66 90 35 94 71 61 34 14<br/>1. Adım Pivot 96<br/>14 15 66 90 35 94 71 61 34 96<br/>2. Adım Pivot 34<br/>14 15 66 90 35 94 71 61 34 96<br/>3. Adım Pivot 66<br/>14 15 34 90 35 94 71 61 66 96<br/>4. Adım Alt Grup Pivot= 61 Üst Grup Pivot=94<br/>14 15 34 35 61 66 71 90 94 96<br/>5. Adım Pivot=90<br/>14 15 34 35 61 66 71 90 94 96<br/>6. Adım Tamamlandı<br/>14 15 34 35 61 66 71 90 94 96<br/>Yukarıda altı aşamada çalışma sistemi verilen sıralama algoritması, aşağıdakilerden hangisidir?",
    "correctAnswer": "D",
    "options": {
      "A": "Pivot sıralama algoritması",
      "B": "Seçerek sıralama algoritması",
      "C": "Baloncuk sıralama algoritması",
      "D": "Hızlı sıralama algoritması",
      "E": "Ekleme sıralama algoritması"
    },
    "explanation": "Metinde verilen sıralama algoritması, <strong>hızlı sıralama algoritması</strong>dır."
  },
  {
    "id": "3624024",
    "unitNumber": 4,
    "text": "Diğerlerine göre daha karmaşık olmasına rağmen performansı en iyi olan sıralama algoritması aşağıdakilerden hangisidir?",
    "correctAnswer": "E",
    "options": {
      "A": "İvmeli sıralama algoritması",
      "B": "Ekleme sıralama algoritması",
      "C": "Baloncuk sıralama algoritması",
      "D": "Seçerek sıralama algoritması",
      "E": "Hızlı sıralama algoritması"
    },
    "explanation": "Diğerlerine göre daha karmaşık olmasına rağmen performansı en iyi olan sıralama algoritması, <strong>hızlı sıralama algoritması</strong>dır."
  },
  {
    "id": "3624169",
    "unitNumber": 4,
    "text": "Algoritma, sıralanacak diziyi baştan itibaren tarar. Bulduğu en küçük elemanı seçer ve dizinin 0 no’lu indeksindeki eleman ile yer değiştirir. İlk adım tamamlanmış olur. İkinci adımda, dizinin 1 no’lu indeksinden itibaren son elemana kadar tarar ve en küçük elemanı tekrar seçer. Seçilen en küçük elemanın 1 no’lu indekste bulunan elemanla yer değiştirilmesi yapıldıktan sonra 2. adım tamamlanır. n elemana sahip dizide n tekrar yapılarak işlem tamamlanır.<br/>Yukarıda sözü edilen sıralama yöntemi aşağıdakilerden hangisidir?",
    "correctAnswer": "A",
    "options": {
      "A": "Selection Sort",
      "B": "Bubble Sort",
      "C": "Insertion Sort",
      "D": "Quick Sort",
      "E": "Standard Sort"
    },
    "explanation": "Bahsi geçen sıralama türü, seçerek sıralamdır; A seçeneği doğrudur."
  },
  {
    "id": "3624170",
    "unitNumber": 4,
    "text": "Dizi elemanlarından biri pivot değer olarak seçilerek algoritma başlatılır. Pivot, baştaki eleman seçilebileceği gibi rastgele bir elemanda seçilebilir. Pivotun dizi elemanlarına uygun seçilmesi algoritma başarısını etkileyecektir. Pivot seçildikten sonra dizinin diğer elemanları, pivottan küçük veya büyük olmasına göre iki gruba ayrılır. Sonraki adımda, bu iki grup kendi içlerinde tekrar bölünerek sıralanır. Grupların sıralaması için sıralama algoritması özyinelemeli (recursive) olarak çalıştırılır.<br/>Yukarıda anlatılan sıralama türü aşağıdakilerden hangisidir?",
    "correctAnswer": "A",
    "options": {
      "A": "Hızlı",
      "B": "Baloncuk",
      "C": "Seçerek",
      "D": "Ekleme",
      "E": "Eksik"
    },
    "explanation": "Bahsi geçen sıralama türü, A seçeneğinde yer alan hızlı sıralamadır."
  },
  {
    "id": "3624171",
    "unitNumber": 4,
    "text": "<ol type=\"I\"> <li>İç Döngü</li> <li>Orta Döngü</li> <li>Dış Döngü</li> </ol> Yukarıdakilerden hangileri seçerek sıralama algoritması kapsamında kullanılır?",
    "correctAnswer": "C",
    "options": {
      "A": "Yalnız I",
      "B": "I ve II",
      "C": "I ve III",
      "D": "II ve III",
      "E": "I, II ve III"
    },
    "explanation": "Seçerek sıralama algoritmasında iki döngü kullanılır. Dış döngü, dizideki ilk ögeden bir sonraki son ögeye doğru hareket ederken iç döngü dizinin ikinci ögesinden son ögeye doğru hareket eder. Algoritma, mevcut adıma ait başlangıç ögesinden küçük ögeleri arar. İç döngünün her yinelemesinden sonra dizideki en küçük değer dizideki uygun yerine atanır"
  },
  {
    "id": "3624172",
    "unitNumber": 4,
    "text": "Aşağıdaki sıralama algoritmalarından hangisinin performansı en yüksektir?",
    "correctAnswer": "A",
    "options": {
      "A": "Hızlı",
      "B": "Sıralama",
      "C": "Baloncuk",
      "D": "Seçerek",
      "E": "Özel"
    },
    "explanation": "Diğer algoritmalara nazaran daha performanslı olan hızlı sıralama algoritması, dikkatli kodlama yapılmadığı takdirde işlem yükü olarak daha maliyetli çalışır."
  },
  {
    "id": "3624173",
    "unitNumber": 4,
    "text": "Listedeki elemanları, ikili olarak yanındaki ile karşılaştırır ve sıralama yapılmak istenen yönde yer değiştirir. Artan sıralama yapılıyorsa büyük olan eleman sağ tarafa, küçük eleman sol tarafa alınarak yerleştirme yapılır.<br/>Yukarıda bahsi geçen sıralama algoritması aşağıdakilerden hangisidir?",
    "correctAnswer": "A",
    "options": {
      "A": "Baloncuk",
      "B": "Hızlı",
      "C": "Ekleme",
      "D": "Seçerek",
      "E": "Özel"
    },
    "explanation": "Listedeki rastgele verilen elemanları artan sıra ile sıralarsak baloncuk sağa doğru kayacaktır. Azalan sıra ile sıralarsak baloncuk sola doğru kayacaktır. Listedeki elemanları, ikili olarak yanındaki ile karşılaştırır ve sıralama yapılmak istenen yönde yer değiştirir. Artan sıralama yapılıyorsa büyük olan eleman sağ tarafa, küçük eleman sol tarafa alınarak yerleştirme yapılır"
  },
  {
    "id": "3624174",
    "unitNumber": 4,
    "text": "Seçerek sıralamada hangi döngünün her yinelemesinden sonra dizideki en küçük değer dizideki uygun yerine atanır?",
    "correctAnswer": "A",
    "options": {
      "A": "İç",
      "B": "Dış",
      "C": "Orta",
      "D": "Başlangı.",
      "E": "Son"
    },
    "explanation": "Seçerek sıralama algoritmasında iki döngü kullanılır. Dış döngü, dizideki ilk ögeden bir sonraki son ögeye doğru hareket ederken iç döngü dizinin ikinci ögesinden son ögeye doğru hareket eder. Algoritma, mevcut adıma ait başlangıç ögesinden küçük ögeleri arar. İç döngünün her yinelemesinden sonra dizideki en küçük değer dizideki uygun yerine atanır."
  },
  {
    "id": "3624175",
    "unitNumber": 4,
    "text": "Bir başka temel sıralama algoritması ise ------- algoritmasıdır. Çalışma esnasında<br/>dizi aralığındaki en küçük elemanı seçerek çalıştığı için bu isim verilmiştir.<br/>Yukarıdaki cümlede boş bırakılan yeri aşağıdakilerden hangisi doğru olarak tamamlar?",
    "correctAnswer": "A",
    "options": {
      "A": "Seçerek Sıralama",
      "B": "Baloncuk Sıralama",
      "C": "Ekleme Sıralama",
      "D": "Hızlı Sıralama",
      "E": "Yavaş Sıralama"
    },
    "explanation": "diğer temel sıralama algoritması Seçerek Sıralama algoritmasıdır. Çalışma esnasında<br/>dizi aralığındaki en küçük elemanı seçerek çalıştığı için bu isim verilmiştir."
  },
  {
    "id": "3624176",
    "unitNumber": 4,
    "text": "Aşağıdakilerden hangisi diğer algoritmalara nazaran daha performanslı olan ancak dikkatli kodlama yapılmadığı takdirde işlem yükü olarak daha maliyetli çalışan bir sıralama algoritmasıdır?",
    "correctAnswer": "A",
    "options": {
      "A": "Hızlı Sıralama",
      "B": "Ekleme Sıralama",
      "C": "Seçerek Sıralama",
      "D": "Baloncuk Sıralama",
      "E": "Veri Sıralama"
    },
    "explanation": "Hızlı Sıralama (Quick Sort) algoritması diğer algoritmalara nazaran daha performanslı olan bu algoritma, dikkatli kodlama yapılmadığı takdirde işlem yükü olarak daha maliyetli çalışır."
  },
  {
    "id": "3624177",
    "unitNumber": 4,
    "text": "Temel sıralama algoritmalarından bir diğeri ise ------- algoritmasıdır. Bu algoritmaya örnek olarak kitaplığına kitapların yerleştirilmesi düşünülebilir. Rastgele dizi hâlinde bulunan kitaplar, sol taraftan başlanarak düzenlenebilir. Her adımda sıradaki kitap önceki kitaplar arasındaki yerine eklenir ve sıradaki kitap alınır.<br/>Yukarıdaki paragrafta boş bırakılan yeri aşağıdakilerden hangisi doğru olarak tamamlar?",
    "correctAnswer": "A",
    "options": {
      "A": "Ekleme Sıralama",
      "B": "Seçerek Sıralama",
      "C": "Hızlı Sıralama",
      "D": "Baloncuk Sıralama",
      "E": "Yavaş Sıralama"
    },
    "explanation": "Temel sıralama algoritmalarından bir diğeri ise Ekleme Sıralama (Insertion Sort) algoritmasıdır. Bu algoritmaya örnek olarak kitaplığına kitapların yerleştirilmesi düşünülebilir. Rastgele dizi hâlinde bulunan kitaplar, sol taraftan başlanarak düzenlenebilir. Her adımda sıradaki kitap önceki kitaplar arasındaki yerine eklenir ve sıradaki kitap alınır."
  },
  {
    "id": "3624178",
    "unitNumber": 4,
    "text": "Sıralama algoritmasında ideal zaman karmaşıklığı değeri aşağıdakilerden hangisi olmalıdır?",
    "correctAnswer": "A",
    "options": {
      "A": "O(1)",
      "B": "O(log n)",
      "C": "O(n)",
      "D": "O(n2)",
      "E": "O(n^n)"
    },
    "explanation": "Sıralama algoritmasında, ideal zaman karmaşıklığı değeri O(1)<br/>olmalıdır."
  },
  {
    "id": "3843531",
    "unitNumber": 4,
    "text": "<em>Bir sıralama algoritmasının performansı, veri __________ ve algoritmanın __________ yapısıyla doğrudan ilişkilidir.</em><br/><strong>Yukarıdaki ifadede boş bırakılan yerlere sırasıyla aşağıdaki seçeneklerden hangisi gelmelidir?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "miktarı - bellek",
      "B": "boyutu - karmaşıklık",
      "C": "işlemcisi - format",
      "D": "sayısı - tip",
      "E": "listesi - donanım"
    },
    "explanation": "Sıralama algoritmalarının verimliliği, işlem görecek verinin <strong>boyutu</strong> ve algoritmanın sahip olduğu <strong>karmaşıklık</strong> derecesi (örneğin O(n), O(n²) gibi) ile ilgilidir. Bu sebeple doğru cevap 'boyutu - karmaşıklık' ifadesidir."
  },
  {
    "id": "3843534",
    "unitNumber": 4,
    "text": "Aşağıda baloncuk sıralama algoritmasına ait kavramlar ve açıklamaları verilmiştir.<br/>Eşleştirmelerden hangisi <strong>doğrudur</strong>?<br/>Kavramlar:<br/>1- Döngü<br/>2- Karşılaştırma<br/>3- Swap (Yer Değiştirme)<br/>4- Son<br/>5- Verimlilik<br/>Açıklamalar:<br/>A) Yer değiştirme yapılırsa devam eder<br/>B) Yandaki elemanla yapılır<br/>C) Sıralı değilse yapılır<br/>D) Tüm geçişler tamamlandığında olur<br/>E) O(n²) karmaşıklığına sahiptir",
    "correctAnswer": "A",
    "options": {
      "A": "1-A, 2-B, 3-C, 4-D, 5-E",
      "B": "1-A, 2-C, 3-B, 4-E, 5-D",
      "C": "1-B, 2-C, 3-A, 4-D, 5-E",
      "D": "1-C, 2-D, 3-A, 4-B, 5-E",
      "E": "1-D, 2-E, 3-B, 4-A, 5-C"
    },
    "explanation": "Baloncuk sıralama, her geçişte yandaki elemanlarla karşılaştırma yaparak yer değiştirme temellidir. İşlemler değişiklik olmayana kadar tekrar eder. En kötü durumu O(n²)’dir."
  },
  {
    "id": "3843538",
    "unitNumber": 4,
    "text": "<ol type=\"I\"> <li>Tüm liste sıralanana kadar devam et</li> <li>Sıradaki alt diziye geçerek işlemi tekrar et</li> <li>Bulunan elemanı ilk elemanla yer değiştir</li> <li>Tüm dizide en küçük elemanı bul</li> </ol> Yukarıdaki adımlar seçerek sıralama algoritmasına aittir. Doğru sıralamayı gösteren şık aşağıdakilerden <strong>hangisidir</strong>?",
    "correctAnswer": "E",
    "options": {
      "A": "I → II → III → IV",
      "B": "I → III → II → IV",
      "C": "II → I → III → IV",
      "D": "III → I → II → IV",
      "E": "IV → III → II → I"
    },
    "explanation": "Seçerek sıralama algoritmasında önce en küçük eleman bulunur, sonra yer değiştirir, sonra alt diziye geçilir. Bu işlem tüm liste sıralanana kadar devam eder."
  },
  {
    "id": "3843541",
    "unitNumber": 4,
    "text": "Bir öğretmen, öğrencilerden aldığı notları sıralı şekilde eklemek istemektedir. Elindeki sıralı not listesi: <strong>40, 50, 70</strong> şeklindedir. Dördüncü öğrenciden gelen <strong>60</strong> notu, bu listeye eklenmek isteniyor. Ekleme sıralama algoritması kullanılırsa hangi adımlar <strong>uygulanır</strong>?",
    "correctAnswer": "D",
    "options": {
      "A": "60, en küçük değer olmadığı için listenin başına eklenir.",
      "B": "60, 40’tan küçük olmadığı için sona eklenir.",
      "C": "60, 50 ile karşılaştırılır; küçük olduğu için 50 ile yer değiştirip başa geçer.",
      "D": "60, 70 ile karşılaştırılıp yer değiştirir; ardından 50 ile karşılaştırılıp daha büyük olduğu için 50’nin sağına yerleştirilir.",
      "E": "60, 70’ten küçük olduğu için doğrudan 70’in yerine yazılır ve işlem sonlandırılır."
    },
    "explanation": "Ekleme sıralamada, yeni gelen öğe sondan başlayarak geriye doğru karşılaştırılır. 60 → 70’ten küçük olduğundan yer değiştirir. Sonra 50 ile karşılaştırılır ve büyük olduğundan onun sağına yerleştirilir. Son liste: <strong>40, 50, 60, 70</strong> olur."
  },
  {
    "id": "3843543",
    "unitNumber": 4,
    "text": "Aşağıdakilerden hangisi Hızlı Sıralama algoritmasının avantajlarından <strong>biridir</strong>?",
    "correctAnswer": "C",
    "options": {
      "A": "Bellek kullanımı çok yüksektir",
      "B": "Daima sabit sürede çalışır",
      "C": "Genellikle O(n log n) sürede çalışır",
      "D": "Tüm durumlarda O(n²) performansı gösterir",
      "E": "Yalnızca sıralı verilerde çalışır"
    },
    "explanation": "Hızlı sıralama algoritması ortalama ve en iyi durumda O(n log n) gibi yüksek performanslı çalışır. Pivot seçimi ile veriyi bölerek sıralar"
  },
  {
    "id": "3843554",
    "unitNumber": 4,
    "text": "Bir yazılım geliştirici, sadece 8 eleman içeren küçük bir listeyi sıralamak için O(n²) ve O(n log n) karmaşıklıklarına sahip iki algoritmayı test etmektedir.<br/>O(n²) algoritma ile sıralama yapıldığında toplamda 64 karşılaştırma yapılmaktadır.<br/>Aynı listeyi O(n log n) karmaşıklığına sahip algoritma ile sıralarsa yaklaşık kaç karşılaştırma yapılması <strong>beklenir</strong>?",
    "correctAnswer": "C",
    "options": {
      "A": "8",
      "B": "16",
      "C": "24",
      "D": "32",
      "E": "64"
    },
    "explanation": "n = 8 olduğunda log₂(8) = 3. O(n log n) algoritma yaklaşık 8 × 3 = 24 karşılaştırma yapar. Bu nedenle doğru cevap C'dir."
  },
  {
    "id": "3843555",
    "unitNumber": 4,
    "text": "\"Bir veri mühendisi, farklı büyüklükteki veri kümeleri için sıralama algoritmalarını değerlendirmektedir. Küçük veri kümelerinde <strong>ekleme sıralama</strong> tercih ederken, büyük veri kümelerinde <strong>hızlı sıralama</strong> algoritmasını kullanmaktadır.\"<br/>Aşağıdakilerden hangisi bu iki algoritmanın ortalama ve tipik performans farkını <strong>doğru şekilde açıklar</strong>?",
    "correctAnswer": "A",
    "options": {
      "A": "Hızlı sıralama ortalama durumda O(n log n) performans gösterirken, ekleme sıralama genellikle O(n²) zaman alır.",
      "B": "Ekleme sıralama büyük veri kümelerinde daha verimlidir.",
      "C": "Hızlı sıralama yalnızca veri sıralı olduğunda çalışır.",
      "D": "Ekleme sıralama, veriyi parçalara ayırıp birleştirerek sıralar.",
      "E": "Hızlı sıralama tüm durumlarda O(n²)’dir."
    },
    "explanation": "<strong>1. Şık - DOĞRU</strong><br/><strong>“Hızlı sıralama ortalama durumda O(n log n)… ekleme sıralama O(n²)….”</strong><br/>Bu ifade iki algoritmanın temel performans farkını doğru şekilde açıklar.<br/>Bu nedenle <strong>doğru cevap budur</strong>.<br/><strong>2. Şık - YANLIŞ</strong><br/><strong>“Ekleme sıralama büyük veri kümelerinde daha verimlidir.”</strong><br/>Tam tersi doğrudur:<br/>Ekleme sıralama küçük veri kümelerinde etkilidir, büyüklerde yavaşlar.<br/><strong>3. Şık - YANLIŞ</strong><br/><strong>“Hızlı sıralama yalnızca veri sıralı olduğunda çalışır.”</strong><br/>Hızlı sıralama her durumda çalışır; veri sıralı olduğunda <em>hatta performansı kötüleşebilir</em>.<br/><strong>4. Şık - YANLIŞ</strong><br/><strong>“Ekleme sıralama, veriyi parçalara ayırıp birleştirerek sıralar.”</strong><br/>Bu, <strong>birleştirme sıralama (merge sort)</strong> tanımıdır.<br/>Ekleme sıralama böyle çalışmaz.<br/><strong>5. Şık - YANLIŞ</strong><br/><strong>“Hızlı sıralama tüm durumlarda O(n²)’dir.”</strong><br/>Sadece kötü durumda O(n²)’dir; ortalama ve en iyi durumda O(n log n)’dir."
  },
  {
    "id": "3843556",
    "unitNumber": 4,
    "text": "<strong>Bir öğrenci, 1.000 elemandan oluşan bir sayısal listeyi sıralamak için Baloncuk Sıralama (Bubble Sort) algoritmasını kullanır.</strong><br/>Baloncuk sıralama algoritması, her geçişte yandaki iki öğeyi karşılaştırır ve gerekirse yer değiştirir.<br/>Bu algoritmada sıralama tamamlanana kadar dizinin baştan sona tekrar tekrar tarandığı varsayılırsa, yaklaşık<strong> kaç karşılaştırma yapılır?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "100",
      "B": "1.000",
      "C": "10.000",
      "D": "100.000",
      "E": "1.000.000"
    },
    "explanation": "<ul><br/><li><br/>Baloncuk sıralama algoritması <strong>n(n-1)/2</strong> kadar karşılaştırma yapar (en kötü durumda).<br/>Çünkü her öğe, tüm diğer öğelerle bir kez karşılaştırılır.<br/></li><br/><li><br/>Bu durumda:<br/><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mn>1000</mn><mo>×</mo><mn>999</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>499.500</mn></mrow><annotation encoding=\"application/x-tex\">\\frac{1000 × 999}{2} = 499.500</annotation></semantics></math>21000×999 =499.500</li><br/><li><br/>Bu sayı <strong>yaklaşık 500.000</strong> olsa da, test sorularında yuvarlama yapılır ve <strong>100.000’e en yakın seçenek D şıkkıdır</strong>.<br/></li><br/><li><br/>E şıkkı olan 1.000.000, <strong>n²</strong> yani <strong>1.000 × 1.000</strong> olsa da, her karşılaştırma için bu kadar işlem yapılmaz.<br/></li><br/></ul>"
  },
  {
    "id": "3843628",
    "unitNumber": 4,
    "text": "Bir e-ticaret platformu, milyonlarca ürünü kullanıcının konumuna ve arama geçmişine göre dinamik olarak sıralamak istiyor. Yüksek performans gereksinimi nedeniyle Hızlı Sıralama algoritması kullanılmasına karar verilmiştir. Ancak testlerde sıralama süresinin beklentinin üzerinde olduğu fark edilmiştir.<br/>Aşağıdaki durumlardan hangisi bu performans sorununa <strong>*en olası açıklamayı* sunar?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "Veri miktarı çok küçük olduğu için algoritma yavaş çalışır",
      "B": "Veri zaten sıralı olduğundan algoritma dengesiz çalışır",
      "C": "Algoritma çok fazla RAM kullandığı için sistem yavaşlar",
      "D": "Kullanılan dil Python olduğu için algoritma etkisiz kalır",
      "E": "Pivot öğe çift sayıda veriyle çalışmaz"
    },
    "explanation": "Hızlı sıralama algoritması, sıralı ya da ters sıralı veri geldiğinde pivotun her zaman uçta seçilmesi nedeniyle dengesiz çalışır ve O(n²) zaman alabilir."
  },
  {
    "id": "3843633",
    "unitNumber": 4,
    "text": "Aşağıdaki ifadelerden hangisi sıralama algoritmalarının genel özelliklerinden biri olan <strong>*kararlılığı (stability)* en doğru şekilde açıklar?</strong>",
    "correctAnswer": "E",
    "options": {
      "A": "Algoritmanın her durumda aynı sürede çalışmasıdır",
      "B": "Sıralı verilerin tersine çevrilmeden işlenmesidir",
      "C": "Bellek kullanımı arttıkça performansın artmasıdır",
      "D": "Veri boyutunun algoritmanın hızına etkisinin olmamasıdır",
      "E": "Aynı değerlere sahip öğelerin sıralama sonrası göreceli konumlarının korunmasıdır"
    },
    "explanation": "Kararlı (stable) bir sıralama algoritması, eşit değerlere sahip öğelerin sıralama sonrası orijinal sırasını korur. Bu özellik özellikle veritabanı işlemlerinde önemlidir."
  },
  {
    "id": "3700063",
    "unitNumber": 5,
    "text": "Aşağıdakilerden hangisi doğrusal aramanın özyinelemeli çözümü için doğru bir koşuldur?",
    "correctAnswer": "B",
    "options": {
      "A": "Dizinin boyutu sıfır olduğunda özyineleme işlemi sona erer",
      "B": "Dizinin boyutu sıfırsa -1 döndürülür",
      "C": "Geçerli eleman anahtara eşitse -1 döndürülür",
      "D": "Aranan eleman bulunana kadar dizi tersine sıralanır",
      "E": "Dizinin boyutu sıfırsa anahtarın bulunduğu indeks döndürülür"
    },
    "explanation": "Doğrusal Arama Özyinelemeli (Recursive) Yaklaşım konusunu yeniden gözden geçiriniz.<br/>Doğrusal aramayı özyinelemeli olarak çözmek için aşağıdaki adımlar takip edilebilir:<br/>• Dizinin boyutu sıfırsa ögenin bulunmadığını gösteren -1 döndürülmelidir. Bu aynı zamanda bir özyineleme çağrısının temel koşulu olarak da ele alınabilir.<br/>• Diğer durumda, dizideki geçerli dizindeki ögenin anahtara eşit olup olmadığı kontrol edilmelidir yani arr[boyut - 1] == aranan_kelime<br/>• Eşit ise bulunan anahtarın dizinini döndürün."
  },
  {
    "id": "3700064",
    "unitNumber": 5,
    "text": "Doğrusal arama algoritmasında en kötü durumda kaç karşılaştırma yapılır?",
    "correctAnswer": "D",
    "options": {
      "A": "2n",
      "B": "n/2",
      "C": "1",
      "D": "n",
      "E": "n log n"
    },
    "explanation": "En Kötü Durum (Worst Case) - O(n) Burada n, listenin/dizinin boyutudur. En kötü durum, hedef öge listenin sonunda bulunduğunda veya liste/dizide bulunmadığında ortaya çıkar. Tüm listedeki elemanların üzerinden geçilmesi gerekmektedir ve bu işlem için n tane karşılaştırma yapılması gerektiğinden zaman karmaşıklığı O(n)’dir."
  },
  {
    "id": "3700065",
    "unitNumber": 5,
    "text": "Doğrusal aramanın ortalama durum zaman karmaşıklığı nedir?",
    "correctAnswer": "A",
    "options": {
      "A": "O(n)",
      "B": "O(n log n)",
      "C": "O(1)",
      "D": "O(log n)",
      "E": "O(n^2)"
    },
    "explanation": "Ortalama Durum (Average Case) - O(n) Doğrusal aramanın ortalama durum karmaşıklığı da O(n)’dir."
  },
  {
    "id": "3700066",
    "unitNumber": 5,
    "text": "Hangi durumda doğrusal aramanın en iyi zaman karmaşıklığı O(1) olur?",
    "correctAnswer": "D",
    "options": {
      "A": "Aranan eleman dizide yoksa",
      "B": "Aranan eleman dizinin ortasında ise",
      "C": "Aranan eleman dizinin başı/sonundaysa",
      "D": "Aranan eleman dizinin başında ise",
      "E": "Aranan eleman dizinin sonunda ise"
    },
    "explanation": "En İyi Durum (Best Case) - O(1) En iyi durum, aranan eleman listenin/dizinin başında bulunduğunda ortaya çıkmaktadır. Yalnızca bir karşılaştırma yapıldığından zaman karmaşıklığı O(1)’dir."
  },
  {
    "id": "3700067",
    "unitNumber": 5,
    "text": "Üçlü arama algoritmasında orta1 ve orta2 nasıl hesaplanır?",
    "correctAnswer": "D",
    "options": {
      "A": "orta1 ve orta2 sabit bir şekilde atanır",
      "B": "orta1 = (sol + sağ) / 3 ve orta2 = (sol + sağ) / 3",
      "C": "orta1 = sol / 3 ve orta2 = sağ / 3",
      "D": "orta1 = sol + (sağ - sol) / 3 ve orta2 = sağ - (sağ - sol) / 3",
      "E": "orta1 = sol + (sağ - sol) / 2 ve orta2 = sağ + (sağ - sol) / 2"
    },
    "explanation": "İkili ve üçlü arama arasındaki tek fark, üçlü aramada orta1 ve orta2 olmak üzere iki orta nokta kullanarak dizi[sol, sağ] şeklinde üç parçaya bölünmesidir; burada orta1 = sol + (sağ - sol) / 3 ve orta2 = sağ - (sağ - sol) / 3. Her yinelemede arama uzayının 2/3’ü yok sayılır ve hedef elemanın bulunabileceği aralık seçilir."
  },
  {
    "id": "3700068",
    "unitNumber": 5,
    "text": "İkili aramanın avantajlarından biri hangisidir?",
    "correctAnswer": "B",
    "options": {
      "A": "Sıralanmamış dizilerde hızlı çalışır",
      "B": "Her yinelemede arama uzayı ikiye bölünür",
      "C": "Veriler sıralanmak zorunda değildir",
      "D": "Herhangi bir ek alana ihtiyaç duymaz",
      "E": "Her zaman O(n) zaman karmaşıklığına sahiptir"
    },
    "explanation": "İkili Aramanın Avantajları<br/><ul><br/><li>Hem kavramları hem de uygulamayı anlamak son derece basittir.</li><br/><li>Sıralanmış bir dizi gerektirse de, her yinelemede tüm koleksiyonu ikiye böldüğü için uzun listelerdeki bir ögeyi oldukça verimli bir şekilde aramaktadır.</li><br/><li>Hedef eleman dizinin orta elemanı ile eşleştiğinde, arama işi O(1) zaman karmaşıklığında gerçekleşir.</li><br/></ul><br/>İkili Aramanın Avantajları<br/><ul> <li>Hem kavramları hem de uygulamayı anlamak son derece basittir.</li> <li>Sıralanmış bir dizi gerektirse de, her yinelemede tüm koleksiyonu ikiye böldüğü için uzun listelerdeki bir ögeyi oldukça verimli bir şekilde aramaktadır.</li> <li>Hedef eleman dizinin orta elemanı ile eşleştiğinde, arama işi O(1) zaman karmaşıklığında gerçekleşir.</li> </ul>"
  },
  {
    "id": "3700069",
    "unitNumber": 5,
    "text": "Aşağıdakilerden hangisi aralıklı arama algoritmalarına örnektir?",
    "correctAnswer": "A",
    "options": {
      "A": "Binary Search",
      "B": "Doğrusal Arama",
      "C": "Dizisel Arama",
      "D": "Kuyruk Arama",
      "E": "Rastgele Arama"
    },
    "explanation": "Aralıklı arama tipine İkili Arama (Binary Search) ve Üçlü Arama (Ternary Search) örnek olarak verilebilir."
  },
  {
    "id": "3700070",
    "unitNumber": 5,
    "text": "İkili arama algoritması hangi tür dizilerde çalışır?",
    "correctAnswer": "C",
    "options": {
      "A": "Sıralanmamış dizilerde",
      "B": "Rastgele dizilerde",
      "C": "Sıralanmış dizilerde",
      "D": "Küçük boyutlu dizilerde",
      "E": "Ters sıralı dizilerde"
    },
    "explanation": "İkili arama, sıralanmış elemanlar üzerinde verimli bir şekilde çalışan bir tür aralıklı arama algoritmasıdır. Aranan elemanın listenin orta ögesiyle karşılaştırıldığı bir böl ve yönet algoritmasıdır. Eşitlerse hedefin orta konumda bulunduğu anlamına gelir. Aksi takdirde arama alanı yarıya indirilir yani hedef &lt; orta öge veya hedef &gt; orta öge olmasına bağlı olarak listenin sol ve sağ yarısından herhangi birine ikili arama uygulanır. Bir eşleşme bulunana veya dizinin boyutu 1’e ulaşana kadar bu işleme devam edilir."
  },
  {
    "id": "3700071",
    "unitNumber": 5,
    "text": "Aralıklı arama algoritmalarında dizi nasıl işlenir?",
    "correctAnswer": "C",
    "options": {
      "A": "Dizi yalnızca iki aralığa bölünür",
      "B": "Dizi üç veya daha fazla aralığa bölünür",
      "C": "Dizi 2 veya 3 aralığa bölünür",
      "D": "Dizi yalnızca artan sıraya göre bölünür",
      "E": "Dizi sadece azalan sıraya göre bölünür"
    },
    "explanation": "Burada dizi her aşamada 2 veya 3 aralığa bölünmüştür. Dizi aralıklara bölündükten sonra bulunacak elemanın beklendiği aralığı belirlenmektedir ve bu aralık daha sonra 2 veya 3 alt aralığa bölünerek alt aralığın uzunluğu 0 olana kadar aynı işlem tekrar edilmektedir."
  },
  {
    "id": "3700072",
    "unitNumber": 5,
    "text": "Aşağıdakilerden hangisi doğrusal aramanın özyinelemeli çözümü için yanlıştır?",
    "correctAnswer": "D",
    "options": {
      "A": "Dizinin boyutu sıfırsa -1 döndürülür",
      "B": "Anahtar bulunana kadar dizinin her elemanı kontrol edilir",
      "C": "En kötü durumda n karşılaştırma yapılır",
      "D": "Geçerli eleman anahtara eşitse dizinin boyutu 0 olur",
      "E": "Eğer anahtar bulunursa anahtarın dizindeki yeri döndürülür"
    },
    "explanation": "Doğrusal Arama Özyinelemeli (Recursive) Yaklaşım Doğrusal aramayı özyinelemeli olarak çözmek için aşağıdaki adımlar takip edilebilir: • Dizinin boyutu sıfırsa ögenin bulunmadığını gösteren -1 döndürülmelidir. Bu aynı zamanda bir özyineleme çağrısının temel koşulu olarak da ele alınabilir. • Diğer durumda, dizideki geçerli dizindeki ögenin anahtara eşit olup olmadığı kontrol edilmelidir yani arr[boyut - 1] == aranan_kelime • Eşit ise bulunan anahtarın dizinini döndürün."
  },
  {
    "id": "3840012",
    "unitNumber": 5,
    "text": "<strong>Listedeki ilk ögeden başlayarak aranılan eleman bulunana veya listenin elemanları tükenene kadar temeldeki sıralı diziyi izleyerek elemanlar arasında geçiş yapılan aram türü aşağıdakilerden hangisidir?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "Doğrusal Arama",
      "B": "Raslantısal Arama",
      "C": "Ardışık Arama",
      "D": "Sıralı Arama",
      "E": "Boyutsal Arama"
    },
    "explanation": "zorluk derecesi: kolay<br/>Ardışık aramada, listedeki ilk ögeden başlayarak aranılan eleman bulunana veya listenin elemanları tükenene kadar temeldeki sıralı diziyi izleyerek elemanlar arasında geçiş yapılmaktadır."
  },
  {
    "id": "3840014",
    "unitNumber": 5,
    "text": "<strong>N elemanlı bir dizide aranan öge dizi içinde yer almıyorsa elde edilecek olan çıktı aşağıdakilerden hangisi olur?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "0",
      "B": "-1",
      "C": "+1",
      "D": "∞",
      "E": "!"
    },
    "explanation": "zorluk derecesi: kolay<br/>N elemanlı bir dizide aranan öge dizi içinde yer almıyorsa elde edilecek olan çıktı -1 olur."
  },
  {
    "id": "3840015",
    "unitNumber": 5,
    "text": "<strong>{10, 30, 80, 20, 110, 70,130, 90, 150, 170} dizisinin üçüncü elemanı aşağıdakilerden hangisidir?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "10",
      "B": "30",
      "C": "80",
      "D": "20",
      "E": "110"
    },
    "explanation": "zorluk derecesi: kolay<br/>Dizinde indisler 0 dan başlar. dolayısıyla ilk eleman 0. indis ile işaretlenir. Bu doğrultuda 3. elamanımız 20 dir."
  },
  {
    "id": "3840016",
    "unitNumber": 5,
    "text": "using System;<br/>class SiraliArama {<br/>public static int arama(int[] dizi, int x)<br/>{<br/>int N = dizi.Length;<br/>for (int i = 0; i &lt; N; i++) {<br/>if (dizi[i] == x)<br/>return i;<br/>}<br/>return -1;<br/>}<br/>public static void Main()<br/>{<br/>int[] dizi= { 2, 3, 4, 10, 40 };<br/>int x = 10;<br/><strong>Yukarıda yer alan kod parçacağında aranan elemanın bulunduğu dizin aşağıdakilerden hangisidir?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "1",
      "B": "2",
      "C": "3",
      "D": "4",
      "E": "5"
    },
    "explanation": "zorluk derecesi: orta<br/>dizinler 0 dan başlamaktadır. soruda aranan ise \"10\" elamanıdır. Dizini 0 dan başlattığımız \"10\" elemanı 3. dizin de yer almaktadır."
  },
  {
    "id": "3840617",
    "unitNumber": 5,
    "text": "I. Dizinin boyutu sıfırsa ögenin bulunmadığını gösteren ∞ döndürülmelidir<br/>II. Dizideki geçerli dizindeki ögenin anahtara eşit olup olmadığı kontrol etmek gerekmektedir.<br/>III. Dizideki geçerli dizindeki ögenin anahtara eşit olduğu durumda dizin sonlandırılır.<br/>IV. Dizinin boyutu sıfırsa ögenin bulunmadığını gösteren döngü özyineleme çağrısının temel koşuludur.<br/><strong>Yukarıdakilerden hangileri doğrusal aramayı özyinelemeli olarak çözmek için izlenen adımlar hakkında doğru <u>değildir</u>?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "I ve II",
      "B": "I ve III",
      "C": "II ve III",
      "D": "III ve IV",
      "E": "I ve IV"
    },
    "explanation": "zorluk derecesi: zor<br/>I. Dizinin boyutu sıfırsa ögenin bulunmadığını gösteren<strong> -1</strong> döndürülmelidir<br/>III. Dizideki geçerli dizindeki ögenin anahtara eşit olduğu durumda dizin <strong>döndürülür</strong>."
  },
  {
    "id": "3840619",
    "unitNumber": 5,
    "text": "Dizi A[] = {3,4,0,9,8}<br/>Hedef öge = 3<br/><strong>Yukarıda verilen durumda hedef aşağıdakilerden hangisidir?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "A[0]",
      "B": "A[1]",
      "C": "A[2]",
      "D": "A[3]",
      "E": "A[4]"
    },
    "explanation": "zorluk derecesi: kolay<br/>dizinler 0 dan başladığı için ilk öge olan \"3\", 0. dizinde yer almaktadır."
  },
  {
    "id": "3840623",
    "unitNumber": 5,
    "text": "...., hedef öge listenin sonunda bulunduğunda veya liste/dizide bulunmadığında ortaya çıkar. Tüm listedeki elemanların üzerinden geçilmesi gerekmektedir ve bu işlem için n tane karşılaştırma yapılması gerektiğinden zaman karmaşıklığı O(n)’dir.<br/><strong>Yukarıdaki boşluğa aşağıdakilerden hangisi gelmelidir?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "Uzay Karmaşıklığı",
      "B": "En Kötü Durum",
      "C": "Ortalama Durum",
      "D": "Zaman Karmaşıklığı",
      "E": "Aralıklı Arama"
    },
    "explanation": "zorluk derecesi: orta<br/><strong>En kötü durum,</strong> hedef öge listenin sonunda bulunduğunda veya liste/dizide bulunmadığında ortaya çıkar. Tüm listedeki elemanların üzerinden geçilmesi gerekmektedir ve bu işlem için n tane karşılaştırma yapılması gerektiğinden zaman karmaşıklığı O(n)’dir."
  },
  {
    "id": "3840625",
    "unitNumber": 5,
    "text": "<strong>Elemanların artan veya azalan sırasına göre aranan eleman için veri setinin sadece belirli kısımlarının kontrol edildiği algoritma aşağıdakilerden hangisidir?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "Hedef Arama",
      "B": "Dizi Arama",
      "C": "Zamansal Arama",
      "D": "Aralıklı Arama",
      "E": "Boylamsal Arama"
    },
    "explanation": "zorluk derecesi: orta<br/>Elemanların artan veya azalan sırasına göre aranan eleman için veri setinin sadece belirli kısımlarının kontrol edildiği algoritmaya <strong>aralıklı arama</strong> denir."
  },
  {
    "id": "3840631",
    "unitNumber": 5,
    "text": "<strong>Girdi olarak verilen dizi uzunluğu dışında herhangi bir boşluk kullanılmadığı veya oluşturulmadığı durumlar aşağıdakilerden hangisi ile açıklanabilir?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "En Kötü Durum",
      "B": "Ortalama Durum",
      "C": "Uzay Karmaşıklığı",
      "D": "En İyi Durum",
      "E": "Zaman Karmaşıklığı"
    },
    "explanation": "zorluk derecesi: orta<br/><strong>Uzay Karmaşıklığı<br/></strong> Girdi olarak verilen dizi uzunluğu dışında herhangi bir boşluk kullanılmadığı veya oluşturulmadığı için O(1)’dir."
  },
  {
    "id": "3840633",
    "unitNumber": 5,
    "text": "...., sıralanmış bir dizideki herhangi bir ögenin konumunu bulmak için kullanılan bir arama tekniğidir.<br/><strong>Yukarıdaki boşluğa aşağıdakilerden hangisi gelmelidir?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "Tekli Arama",
      "B": "Üçlü arama",
      "C": "Dörtlü Arama",
      "D": "Uzay Karmaşıklığı",
      "E": "Zaman Karmaşıklığı"
    },
    "explanation": "zorluk derecesi: kolay<br/><strong>Üçlü arama,</strong> sıralanmış bir dizideki herhangi bir ögenin konumunu bulmak için kullanılan bir arama tekniğidir"
  },
  {
    "id": "3845253",
    "unitNumber": 5,
    "text": "<strong>Doğrusal arama algoritması hangi durumda en verimli şekilde çalışır?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "Aranan eleman listenin sonunda ise",
      "B": "Liste sıralı değilse",
      "C": "Aranan eleman ilk sıradaysa",
      "D": "Liste boş ise",
      "E": "Liste büyükse"
    },
    "explanation": "zorluk derecesi: orta<br/>En iyi durum, aranan elemanın ilk sırada olmasıdır ve bu durumda karmaşıklık O(1)’dir."
  },
  {
    "id": "3845255",
    "unitNumber": 5,
    "text": "<strong>Aşağıdakilerden hangisi Aralıklı (Interval) Arama algoritması için <u>yanlıştır</u>?</strong>",
    "correctAnswer": "E",
    "options": {
      "A": "Liste sıralı olmalıdır",
      "B": "Her adımda dizi üç parçaya bölünür",
      "C": "Ortalama karmaşıklığı O(log n)’dir",
      "D": "Ekstra alan kullanmaz",
      "E": "Liste sıralı değilse de çalışır"
    },
    "explanation": "zorluk derecesi: kolay<br/>Aralıklı arama algoritmaları yalnızca sıralı dizilerde kullanılabilir."
  },
  {
    "id": "3845257",
    "unitNumber": 5,
    "text": "<strong>Aşağıdakilerden hangisi sıralı arama algoritması için doğrudur?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "Arama her zaman dizinin ortasından başlar.",
      "B": "Aranan eleman yalnızca sıralı dizilerde bulunabilir.",
      "C": "Her durumda O(log n) karmaşıklık gösterir.",
      "D": "Arama elemanı baştan sona sırayla karşılaştırır.",
      "E": "Dizide eleman yoksa hata verir."
    },
    "explanation": "Zorluk derecesi: kolay<br/>Sıralı arama dizinin başından başlar ve elemanları sırayla kontrol eder."
  },
  {
    "id": "3845260",
    "unitNumber": 5,
    "text": "<strong>İkili arama algoritmasının ortalama zaman karmaşıklığı aşağıdakilerden hangisidir?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "O(n)",
      "B": "O(n²)",
      "C": "O(log n)",
      "D": "O(1)",
      "E": "O(n log n)"
    },
    "explanation": "zorluk derecesi: zor<br/>İkili arama algoritması her yinelemede diziyi ikiye böldüğü için ortalama karmaşıklığı O(log n)’dir"
  },
  {
    "id": "3845261",
    "unitNumber": 5,
    "text": "<strong>Doğrusal arama algoritması ile ilgili aşağıdakilerden hangisi doğrudur?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "En kötü durum karmaşıklığı O(1)’dir.",
      "B": "Liste sıralı değilse çalışmaz.",
      "C": "Ekstra bellek kullanımı vardır.",
      "D": "Özyinelemeli olarak da uygulanabilir.",
      "E": "Sadece tamsayı dizileri ile çalışır."
    },
    "explanation": "zorluk derecesi: orta<br/>Doğrusal arama algoritması özyinelemeli olarak da kodlanabilir."
  },
  {
    "id": "3845262",
    "unitNumber": 5,
    "text": "<strong>Üçlü arama algoritması hangi özelliği ile ikili aramadan ayrılır?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "Yalnızca tek arama bölgesi kullanması",
      "B": "Kodlama zorluğu",
      "C": "Verileri sıralamaya gerek duymaması",
      "D": "Dizi iki yerine üç parçaya bölünür",
      "E": "Daha fazla karmaşıklık üretmesi"
    },
    "explanation": "zorluk derecesi: kolay<br/>Üçlü arama algoritması diziyi iki yerine üç parçaya ayırarak çalışır."
  },
  {
    "id": "3845263",
    "unitNumber": 5,
    "text": "<strong>Aşağıdaki ifadelerden hangisi <u>yanlıştır</u>?</strong>",
    "correctAnswer": "E",
    "options": {
      "A": "Sıralı arama sırasız dizilerde de kullanılabilir.",
      "B": "İkili arama sıralı dizilerde kullanılmalıdır.",
      "C": "Üçlü arama karmaşıklık olarak O(log n)’dir.",
      "D": "Tüm arama algoritmaları aynı uzay karmaşıklığına sahiptir.",
      "E": "Doğrusal arama her zaman en hızlı yöntemdir."
    },
    "explanation": "zorluk derecesi: orta<br/>Doğrusal arama, sıralı olmayan dizilerde uygundur ancak sıralı dizilerde ikili ya da üçlü arama çok daha verimlidir."
  },
  {
    "id": "3845265",
    "unitNumber": 5,
    "text": "Sıralı arama algoritmasında, aranan eleman dizinin ilk elemanında ise zaman karmaşıklığı __________ olur.<br/><strong>Yukarıdaki boşluğa aşağıdakilerden hangisi gelmelidir?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "O(n²)",
      "B": "O(n)",
      "C": "O(log n)",
      "D": "O(1)",
      "E": "O(n log n)"
    },
    "explanation": "zorluk derecesi: orta<br/>İlk elemanda bulunduğu durumda sadece bir karşılaştırma yapılır ve karmaşıklık sabit olur: O(1)"
  },
  {
    "id": "3845266",
    "unitNumber": 5,
    "text": "Aralıklı arama algoritması yalnızca __________ diziler üzerinde çalışır.<br/><strong>Yukarıdaki boşluğa aşağıdakilerden hangisi gelmelidir?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "karışık",
      "B": "sıralı",
      "C": "rastgele",
      "D": "çift elemanlı",
      "E": "kısa"
    },
    "explanation": "zorluk derecesi: kolay<br/>Aralıklı arama (ikili ve üçlü), yalnızca sıralı dizilerde anlamlıdır."
  },
  {
    "id": "3845268",
    "unitNumber": 5,
    "text": "Üçlü arama algoritması, arama işlemi sırasında diziyi __________ parçaya böler.<br/><strong>Yukarıdaki boşluğa aşağıdakilerden hangisi gelmelidir?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "iki",
      "B": "dört",
      "C": "bir",
      "D": "üç",
      "E": "beş"
    },
    "explanation": "zorluk derecesi: orta<br/>Üçlü arama algoritması, diziyi orta1 ve orta2 olmak üzere iki noktadan bölerek üç parçaya ayırır."
  },
  {
    "id": "3700073",
    "unitNumber": 6,
    "text": "I. Ekleme ve silmeler, dizi yapılarına göre daha fazla maliyetle yapılmaktadır.<br/>II. Önceden bellek ayırmaya gerek yoktur.<br/>III. Listeyi oluşturan düğümler arasında dolaşmak, dizi yapılarına göre daha zordur.<br/>IV. Liste elemanlarına rastgele erişim mümkündür.<br/><strong>Yukarıdakilerden hangileri bağlantılı liste yapıları için doğrudur?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "I ve II",
      "B": "I ve III",
      "C": "II ve III",
      "D": "III ve IV",
      "E": "II ve IV"
    },
    "explanation": "zorluk derecesi: zor<br/>I. Ekleme ve silmeler, dizi yapılarına göre daha <strong>az</strong> maliyetle yapılmaktadır.<br/>IV. Liste elemanlarına rastgele erişim mümkün <strong>değildir</strong>."
  },
  {
    "id": "3700074",
    "unitNumber": 6,
    "text": "<strong>Aşağıdakilerden hangisi bağlantılı liste yapılarının dezavantajları arasında <u>yer almaz?</u></strong>",
    "correctAnswer": "E",
    "options": {
      "A": "Aynı boyuttaki dizi elemanına oranla bağlantılı listenin kullandığı bellek miktarı daha fazladır.",
      "B": "Listeyi oluşturan düğümler arasında dolaşmak, dizi yapılarına göre daha zordur.",
      "C": "Tek yönlü bağlantılı listelerde önceki elemana dönmek mümkün değildir.",
      "D": "Liste elemanlarına rastgele erişim mümkün değildir.",
      "E": "Bağlantılı listelerde, liste boyutu ihtiyaç oldukça arttırılır."
    },
    "explanation": "zorluk derecesi: zor<br/>Bağlantılı listelerde, liste boyutu ihtiyaç oldukça arttırılır- ifadesi <strong>avantajlı</strong> taraflarından birisidir."
  },
  {
    "id": "3700075",
    "unitNumber": 6,
    "text": "<strong>Aşağıdakilerden hangisi bağlantılı liste yapıları için <u>yanlıştır</u>?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "Bağlantılı liste, düğüm(node) adı verilen sınıf nesnelerinin oluşturduğu bir yapıdır.",
      "B": "Düğümler, verileri tutacakları alanlardan ve referans için ayrılan bölümlerden oluşur.",
      "C": "Düğümlerin referans noktaları ile birleştirilmesi geçiş olarak adlandırılır.",
      "D": "Her düğüm, bir sonraki düğümün referans adresini tutar.",
      "E": "Bağlantılı listelerde, liste boyutu ihtiyaç oldukça arttırılır."
    },
    "explanation": "zorluk derecesi: orta<br/>Düğümlerin referans noktaları ile birleştirilmesi <strong>bağlantı</strong> olarak adlandırılır."
  },
  {
    "id": "3700076",
    "unitNumber": 6,
    "text": "I. Bağlantılı listeyi Başlık(Head) isimli bir düğüm ile başlatmak yaygın bir kullanımdır.<br/>II. Bağlantılı listenin sonundaki düğüm kilit düğüm olarak adlandırılır.<br/>III. Bir listede veri 20’ye ulaşmak için öncelikle Veri 10’un olduğu düğüme ulaşılması gerekir.<br/>IV. Yeni düğümün adresi, ekleneceği sıradan bir önceki düğümün ilk ögesine yazılır.<br/><strong>Yukarıdakilerden hangileri bağlantılı listelerde yer alan düğümler için doğrudur?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "I ve II",
      "B": "I ve III",
      "C": "II ve III",
      "D": "III ve IV",
      "E": "II ve IV"
    },
    "explanation": "zorluk derecesi: orta<br/>II. Bağlantılı listenin sonundaki düğüm <strong>Son</strong> düğüm olarak adlandırılır.<br/>IV. Yeni düğümün adresi, ekleneceği sıradan bir önceki düğümün <strong>Sonraki</strong> ögesine yazılır."
  },
  {
    "id": "3700077",
    "unitNumber": 6,
    "text": "<strong>Aşağıdakilerden hangisi nesne odaklı bağlantılı liste yapısını oluşturmak için hazırlanan sınıflar hakkında doğru <u>değildir</u>?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "Bağlantılı liste oluşturmak için kullanılan düğüm, üç alandan oluşur.",
      "B": "Farklı türde verilerin kullanılabilmesi için veri object türünde olmalıdır.",
      "C": "Link türü düğüm olarak düzenlenir.",
      "D": "Düğüm oluşturulurken hem Öge, hemde Link null olarak atanmalıdır.",
      "E": "Listeyi başlatan bir yapıcı metoduna ihtiyaç vardır."
    },
    "explanation": "zorluk derecesi: orta<br/>Bağlantılı liste oluşturmak için kullanılan düğüm, <strong>iki</strong> alandan oluşur."
  },
  {
    "id": "3700078",
    "unitNumber": 6,
    "text": "<strong>1000 elemandan oluşan bir listede iken 999. ögeye gelmenin maliyetini azaltan ve bu işlemi kolaylaştıran tasarım aşağıdakilerden hangisidir?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "Tek yönlü Bağlantılı Liste",
      "B": "Çift Yönlü Bağlantılı Liste",
      "C": "Tek yönlü Bağlantılı Düğüm",
      "D": "Çift Yönlü Bağlantılı Düğüm",
      "E": "null.list"
    },
    "explanation": "zorluk seviyesi: kolay<br/>1000. elemanda iken 999. ögeye gelmek oldukça maliyetli bir işlemdir. Bu gibi ihtiyaçlar için <strong>çift bağlantılı liste (doubly linked list)</strong> tasarımı geliştirilmiştir"
  },
  {
    "id": "3700079",
    "unitNumber": 6,
    "text": "I. Bir düğüm kolayca silinmez.<br/>II. Bellekte daha fazla alan kaplar.<br/>III. Ögelere rastgele erişim imkânı yoktur.<br/>IV. Diğer çeşitli veri yapılarının uygulanması zordur.<br/><strong>Yukarıdakilerden hangileri çift bağlantılı liste yapıları ile ilgili olarak doğrudur?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "I ve II",
      "B": "I ve III",
      "C": "II ve III",
      "D": "III ve IV",
      "E": "II ve IV"
    },
    "explanation": "zorluk derecesi: orta<br/>I. Bir düğüm kolayca <strong>silinebilir</strong>.<br/>IV. Diğer çeşitli veri yapılarının uygulanması <strong>kolaydır</strong>."
  },
  {
    "id": "3700080",
    "unitNumber": 6,
    "text": "<strong> Bağlantılı listenin son elemanının ilk düğümü işaret ettiği liste yapısı aşağıdakilerden hangisidir?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "Tek yönlü Bağlantılı Liste",
      "B": "Çift Yönlü Bağlantılı Liste",
      "C": "Tek Yönlü Bağlantılı Düğüm",
      "D": "Dairesel Bağlantılı Liste",
      "E": "Çift Yönlü Bağlantılı Düğüm"
    },
    "explanation": "zorluk derecesi: kolay<br/>Bağlantılı listelerle ilgili inceleyeceğimiz ikinci tasarım ise bağlantılı listenin son elemanının ilk düğümü işaret ettiği <strong>Dairesel Bağlantılı Liste’dir. </strong>"
  },
  {
    "id": "3700081",
    "unitNumber": 6,
    "text": "<strong>Dairesel bağlantılı listenin sonunu kontrol etmek için aşağıdakilerden hangisi kontrol edilir?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "Başlık düğümü",
      "B": "Link alanı",
      "C": "Veri seti",
      "D": "Null düğümü",
      "E": "Private düğümü"
    },
    "explanation": "zorluk derecesi: kolay<br/>Bağlantılı listenin sonunu kontrol etmek için son düğümün<br/>Link alanının boş olması değil, <strong>başlık düğümünü</strong> gösterip göstermediği kontrol edilir."
  },
  {
    "id": "3700082",
    "unitNumber": 6,
    "text": "<strong>Dairesel bağlantılı listeler için aşağıdakilerden hangisi <u>yanlıştır</u>?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "Kodda NULL(boş) atamasına gerek yoktur.",
      "B": "Tek yönlü bağlantılı listelere göre daha basit bir yapıdadır.",
      "C": "Dikkatli kodlama yapılmadığı takdirde program sonsuz döngüye girer.",
      "D": "Dairesel bağlantılı listeyi tersine çevirmek, diğer yapılara göre daha zordur.",
      "E": "Listenin sonunu ve döngü kontrolünü bulmak daha zordur."
    },
    "explanation": "zorluk derecesi: orta<br/>Tek yönlü bağlantılı listelere göre daha <strong>komplekstir</strong>."
  },
  {
    "id": "3842033",
    "unitNumber": 6,
    "text": "I. Dizide sıralı eleman eklemek için birçok elemanı kaydırmak gerekebilir.<br/>II. n elemanlı dizide ortadaki elemanın diziden çıkarılması için çıkarılan elemandan sonraki tüm ögelerin taşınması gerekir.<br/>III. Verileri bağlantılı listelerde tutmak, ekleme ve çıkarma işlemlerinin maliyetlerini artırır.<br/>IV. İhtiyaca göre farklı veri yapıları kullanmak, yeni başlayan program geliştiricileri için genellikle kolaydır.<br/><strong>Yukarıdaki ifadelerden hangileri <u>yanlıştır</u>?</strong>",
    "correctAnswer": "E",
    "options": {
      "A": "I ve II",
      "B": "I ve III",
      "C": "II ve III",
      "D": "II ve IV",
      "E": "III ve IV"
    },
    "explanation": "zorluk derecesi: orta<br/>III. Verileri bağlantılı listelerde tutmak, ekleme ve çıkarma işlemlerinin maliyetlerini <strong>azaltır</strong>.<br/>IV. İhtiyaca göre farklı veri yapıları kullanmak, yeni başlayan program geliştiricileri için genellikle <strong>zordur</strong>. Uzman yazılımcılar için kolaydır."
  },
  {
    "id": "3842057",
    "unitNumber": 6,
    "text": "<strong>Aşağıdakilerden hangisi bağlantılı liste yapılarının avantajlarından biri <u>değildir</u>?</strong>",
    "correctAnswer": "E",
    "options": {
      "A": "Ekleme ve silmeler, dizi yapılarına göre daha az maliyetle yapılabilir.",
      "B": "Büyük kayıtlarda, yapıdaki elemanları taşımak veya yer değiştirmek birçok işlem gerektirir. Bunun yerine ögelerin işaretçilerini taşımak çok daha az maliyetlidir.",
      "C": "Bağlantılı listelerde, liste boyutu ihtiyaç oldukça arttırılır. Önceden bellek ayırmaya gerek yoktur. Gereksiz bellek kullanımını azaltır.",
      "D": "Yığın, kuyruk gibi veri yapıları; bağlantılı listeler ile kolaylıkla uygulanabilir.",
      "E": "Listeyi oluşturan düğümler arasında dolaşmak, dizi yapılarına göre daha zordur."
    },
    "explanation": "zorluk derecesi: kolay<br/>Listeyi oluşturan düğümler arasında dolaşmak, dizi yapılarına göre daha zordur. seçeneği Bağlantılı liste yapılarının sınırlılıkları arasında yer alır."
  },
  {
    "id": "3842061",
    "unitNumber": 6,
    "text": "I. Her düğüm, bir sonraki düğümün referans adresini tutar.<br/>II. Düğümlerin referans noktaları ile birleştirilmesi bağlantı olarak adlandırılır.<br/>III. Bağlantılı liste, nokta adı verilen sınıf nesnelerinin oluşturduğu bir yapıdır.<br/>IV. Düğümler, verileri tutacakları alanlardan ve referans için ayrılan bölümlerden oluşur.<br/><strong>Yukarıdaki ifadelerden hangileri bağlantılı liste yapıları için doğrudur?</strong>",
    "correctAnswer": "E",
    "options": {
      "A": "I ve II",
      "B": "I ve II",
      "C": "II ve III",
      "D": "III ve IV",
      "E": "I, II ve IV"
    },
    "explanation": "zorluk derecesi: kolay<br/>III. Bağlantılı liste, <strong>düğüm</strong> adı verilen sınıf nesnelerinin oluşturduğu bir yapıdır"
  },
  {
    "id": "3842069",
    "unitNumber": 6,
    "text": "<img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/e8514e6160bc48f3eae9a02124e20bc4.png\" alt=\"\" width=\"597\" height=\"74\"><br/><strong>Aşağıdaki ifadelerden hangisi yukarıda yer alan bağlantılı liste yapısı için doğru <u>değildir</u>?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "Bağlantılı liste elemanları birbirine eklenerek tutulur.",
      "B": "Veri 20’ye ulaşmak için öncelikle Veri 10’un olduğu düğüme ulaşılması gerekir.",
      "C": "Bağlantılı listenin sonundaki düğüm ise Son Düğüm olarak adlandırılır.",
      "D": "Bağlantılı liste yapısında yeni veri eklenmesi, dizi yapısına göre daha fazla maliyetli bir işlemdir.",
      "E": "Son düğümün bir ardıl düğümü gösterecek Sonraki alanı boş(null) olarak atanmalıdır."
    },
    "explanation": "zorluk derecesi: orta<br/>Bağlantılı liste yapısında yeni veri eklenmesi, dizi yapısına göre daha <strong>az</strong> maliyetli bir işlemdir."
  },
  {
    "id": "3842073",
    "unitNumber": 6,
    "text": "Bir bağlantılı listede, farklı türde verilerin kullanılabilmesi için veri ...... türünde olmalıdır.<br/><strong>Yukarıda yer alan boşluğa gelebilecek en doğru seçenek aşağıdakilerden hangisidir?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "Oge",
      "B": "Object",
      "C": "Nokta",
      "D": "Düğüm",
      "E": "Link"
    },
    "explanation": "zorluk derecesi: orta<br/>Farklı türde verilerin kullanılabilmesi için veri <strong>object</strong> türünde olmalıdır."
  },
  {
    "id": "3842077",
    "unitNumber": 6,
    "text": "<strong>Bağlantılı listeler ile ilgilli olarak aşağıda verilenlerden hangisi <u>yanlıştır</u>?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "BagliListe sınıfı, bağlantılı listenin düğümleri arasındaki bağlantıyı kırmak için kullanılır.",
      "B": "Başlık düğümü, Link alanı boş ayarlanmış olarak başlar.",
      "C": "Listeye ilk düğüm eklendiğinde, başlık düğümünün Link alanına yeni düğümün referansı atanır.",
      "D": "Bul metodu, listede ögeleri taramaya başlarken ilk olarak boş bir düğüm oluşturur ve bu düğüme başlık düğümünü atar.",
      "E": "Bağlantılı listeden düğüm kaldırmak için, kaldırılmak istenilen düğümden önceki düğümü bulunup,<br/>sonraki düğüm referans olarak gösterilmelidir."
    },
    "explanation": "zorluk derecesi: orta<br/>BagliListe sınıfı, bağlantılı listemizin düğümleri arasındaki bağlantıyı <strong>oluşturmak</strong> için kullanılır."
  },
  {
    "id": "3842085",
    "unitNumber": 6,
    "text": "<strong>Aşağıdakilerden hangisi çift bağlantılı liste kullanımının avantajlarından biri <u>değildir</u>?</strong>",
    "correctAnswer": "E",
    "options": {
      "A": "Her iki yönde gezinmeye imkân sağlar.",
      "B": "Ters çevirmek kolaydır.",
      "C": "Dinamik olarak büyüyebilir veya küçülebilir.",
      "D": "Diğer çeşitli veri yapılarının uygulanmasında kullanışlıdır.",
      "E": "Bu tasarımda da ögelere rastgele erişim imkânı yoktur."
    },
    "explanation": "zorluk derecesi: kolay<br/>Bu tasarımda da ögelere rastgele erişim imkânı yoktur. ifadesi çift bağlantılı liste kullanımınınsınırlılığı ile ilişkilidir."
  },
  {
    "id": "3842088",
    "unitNumber": 6,
    "text": "I. İşlemler daha fazla zaman gerektirir.<br/>II. Ters çevirmek kolaydır.<br/>III. Her düğüm fazladan bir referans alanına sahiptir. <br/>IV. Bir önceki düğüme erişim olduğu için bir düğüm kolayca silinebilir. <br/><strong>Yukarıdaki ifadelerden hangileri çift bağlantılı liste kullanımının dezavantajları arasında yer alır?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "I ve II",
      "B": "I ve III",
      "C": "II ve III",
      "D": "II ve IV",
      "E": "III ve IV"
    },
    "explanation": "zorluk derecesi: orta<br/>II. Ters çevirmek kolaydır.<br/>IV. Bir önceki düğüme erişim olduğu için bir düğüm kolayca silinebilir.<br/>Bu ifadeler avantajları ile ilgilidir."
  },
  {
    "id": "3842092",
    "unitNumber": 6,
    "text": "<table> <tbody> <tr> <td>I. Bu veri yapısında her düğüm, bir önceki düğümü işaret eder.<br/>II. Listenin son düğümü ilk düğümü işaret eder.<br/>III. Dairesel bağlantılı listelerin bir sonu yoktur.<br/>IV. Gezinme yapıldığında sürekli sona gidilir.<br/><strong>Yukarıdaki ifadelerden hangileri dairesel bağlantılı liste kullanımı ile ilgili olarak doğrudur?</strong></td> </tr> </tbody> </table>",
    "correctAnswer": "C",
    "options": {
      "A": "I ve II",
      "B": "I ve III",
      "C": "II ve III",
      "D": "II ve IV",
      "E": "III ve IV"
    },
    "explanation": "zorluk derecesi: orta<br/>I. Bu veri yapısında her düğüm, bir <strong>sonraki</strong> düğümü işaret eder.<br/>IV. Gezinme yapıldığında sürekli <strong>başa dönülür.</strong>"
  },
  {
    "id": "3842093",
    "unitNumber": 6,
    "text": "<table> <tbody> <tr> <td>I. Kodda NULL(boş) atamasına gerek yoktur.<br/>II. Tek yönlü bağlantılı listelere göre daha komplekstir.<br/>III. Dairesel bir listede herhangi bir düğüm, başlangıç noktası olabilir.<br/>IV. Dairesel bağlantılı listeyi tersine çevirmek, diğer yapılara göre daha zordur.<br/><strong>Yukarıdaki ifadelerden hangileri dairesel bağlantılı listelerin avantajları arasında yer alır?</strong></td> </tr> </tbody> </table>",
    "correctAnswer": "B",
    "options": {
      "A": "I ve II",
      "B": "I ve III",
      "C": "II ve III",
      "D": "II ve IV",
      "E": "III ve IV"
    },
    "explanation": "zorluk derecesi: kolay<br/><table> <tbody> <tr> <td>II. Tek yönlü bağlantılı listelere göre daha komplekstir.<br/>IV. Dairesel bağlantılı listeyi tersine çevirmek, diğer yapılara göre daha zordur.<br/><strong>bu ifadeler dairesel bağlantılı listelerin dezavantajları arasında yer alır?</strong></td> </tr> </tbody> </table>"
  },
  {
    "id": "3719329",
    "unitNumber": 7,
    "text": "Bilgisayar bilimlerinde ağaç; verilerin düğümlerde tutulduğu, düğümlerin birbirlerine kenarlar ile bağlandığı doğrusal olmayan bir veri yapısıdır. Bu ağaçların ilk düğümüne ne ad verilir?",
    "correctAnswer": "A",
    "options": {
      "A": "Kök",
      "B": "Kenar",
      "C": "Yaprak",
      "D": "Dal",
      "E": "İlmek"
    },
    "explanation": "Ağaçların ilk düğümüne kök (root) adı verilir."
  },
  {
    "id": "3719330",
    "unitNumber": 7,
    "text": "Kök düğüme başka bir düğüm bağlanması durumunda hangi adı alır?",
    "correctAnswer": "A",
    "options": {
      "A": "Ebeveyn düğüm",
      "B": "İlk düğüm",
      "C": "Çocuk düğüm",
      "D": "Sıralı düğüm",
      "E": "Son düğüm"
    },
    "explanation": "Kök, düğüme başka bir düğüm bağlanırsa kök düğüm ebeveyn düğüm (parent node) olarak; bağlanan düğüm ise çocuk düğüm (child node) olarak adlandırılır."
  },
  {
    "id": "3719331",
    "unitNumber": 7,
    "text": "Hiyerarşik yapı üzerinde hiçbir kısıtlaması olmayan ağaç veri yapısına ne ad verilir?",
    "correctAnswer": "A",
    "options": {
      "A": "Genel ağaç",
      "B": "İkili ağaç",
      "C": "İkili arama ağacı",
      "D": "Yaylı ağaç",
      "E": "B ağacı"
    },
    "explanation": "Genel ağaç, hiyerarşik yapı üzerinde hiçbir kısıtlaması olmayan bir tür ağaç veri yapısıdır. Genel bir ağaçta her düğümün sonsuz sayıda çocuğu olabilir."
  },
  {
    "id": "3719333",
    "unitNumber": 7,
    "text": "Diğer ağaç veri yapılarından farklı olarak yönetim ve karmaşık algoritmalar gerektirmeyen kendi kendini organize eden yapıdaki ağaç aşağıdakilerden hangisidir?",
    "correctAnswer": "A",
    "options": {
      "A": "Treap",
      "B": "Yaylı",
      "C": "Kırmızı-siyah",
      "D": "AVL",
      "E": "İkili"
    },
    "explanation": "Diğer ağaç veri yapılarından farklı olarak treap, yönetim ve karmaşık algoritmalar gerektirmeyen kendi kendini organize eden bir yapıdır."
  },
  {
    "id": "3719340",
    "unitNumber": 7,
    "text": "Tüm düğümlerin çocuk sayısı iki veya sıfır olan ikili ağaçlara ne ad verilir?",
    "correctAnswer": "A",
    "options": {
      "A": "Tam",
      "B": "Mükemmel",
      "C": "Eksiksiz",
      "D": "Çarpık",
      "E": "Dengeli"
    },
    "explanation": "Tüm düğümlerin çocuk sayısı, iki veya sıfır olan ağaçlara tam ikili ağaç denir.."
  },
  {
    "id": "3719343",
    "unitNumber": 7,
    "text": "Tüm düğümlerin yalnızca bir çocuğu olduğu veya hiç çocuğu olmadığı tür ikili ağaçlara ne ad verilir?",
    "correctAnswer": "A",
    "options": {
      "A": "Çarpık",
      "B": "Dengeli",
      "C": "Tam",
      "D": "Dejenere",
      "E": "Mükemmel"
    },
    "explanation": "Çarpık ikili ağaç, tüm düğümlerin yalnızca bir çocuğu olduğu veya hiç çocuğu olmadığı bir tür ikili ağaçtır"
  },
  {
    "id": "3719344",
    "unitNumber": 7,
    "text": "İkili arama ağacı yapısından en kolay çıkartılabilen, hiç çocuk düğüme sahip olmayan düğümler aşağıdakilerden hangisidir?",
    "correctAnswer": "A",
    "options": {
      "A": "Yaprak",
      "B": "Ana",
      "C": "Kök",
      "D": "İkinci",
      "E": "Çift"
    },
    "explanation": "İkili arama ağacı yapısından en kolay çıkartılacak düğüm, hiç çocuk düğüme sahip olmayan yaprak düğümlerdir."
  },
  {
    "id": "3719349",
    "unitNumber": 7,
    "text": "Kökün çocuklar içinde gösterildiği kök türü aşağıdakilerden hangisiyle anılır?",
    "correctAnswer": "A",
    "options": {
      "A": "İç",
      "B": "Sonra",
      "C": "Önce",
      "D": "İkili",
      "E": "Çift"
    },
    "explanation": "Kökün çocuklar içinde gösterildiği İç Kök (infix) olarak da adlandırılır."
  },
  {
    "id": "3719350",
    "unitNumber": 7,
    "text": "Tüm düğümlerin yalnızca bir çocuğu olduğu veya hiç çocuğu olmadığı ve tüm çocuk düğümlerin aynı taraftan eklendiği ikili ağaç türü aşağıdakilerden hangisidir?",
    "correctAnswer": "A",
    "options": {
      "A": "Çarpık",
      "B": "Dengeli",
      "C": "Mükemmel",
      "D": "Dejenere",
      "E": "Rassal"
    },
    "explanation": "Çarpık ikili ağaç, tüm düğümlerin yalnızca bir çocuğu olduğu veya hiç çocuğu olmadığı bir tür ikili ağaçtır."
  },
  {
    "id": "3719353",
    "unitNumber": 7,
    "text": "İki çocuk düğümü de dolu olan ögeleri kaldırmak, daha önceki kaldırma yöntemlerine göre biraz daha farklıdır. Öge kaldırıldıktan sonra yerine atanacak ...... düğümün belirlenmesi gerekir.<br/>Yukarıdaki metinde boş bırakılan yere aşağıdaki kavramlardan hangisi gelmelidir?",
    "correctAnswer": "A",
    "options": {
      "A": "varis",
      "B": "dugum",
      "C": "kök",
      "D": "yaprak",
      "E": "sonsal"
    },
    "explanation": "İki çocuk düğümü de dolu olan ögeleri kaldırmak, daha önceki kaldırma yöntemlerine göre biraz daha farklıdır. Öge kaldırıldıktan sonra yerine atanacak <strong>varis</strong> düğümün belirlenmesi gerekir."
  },
  {
    "id": "3840543",
    "unitNumber": 7,
    "text": "Bir ikili arama ağacına sırasıyla 17, 7, 25, 2, 10, 33, 1, 3, 8, 13, 29, 35 sayıları eklenirse, 8 sayısını bulmak için kaç adım gerekir?",
    "correctAnswer": "B",
    "options": {
      "A": "2",
      "B": "4",
      "C": "6",
      "D": "8",
      "E": "10"
    },
    "explanation": "Ağaç yapısı oluşturulduğunda 17 → 7 → 10 → 8 yolunu izleriz. Bu 4 adımda hedefe ulaşıldığını gösterir."
  },
  {
    "id": "3840545",
    "unitNumber": 7,
    "text": "Aşağıdakilerden hangisi bir ikili ağacın <strong>eksiksiz ikili ağaç</strong> olduğunu göstermeye yeterlidir?",
    "correctAnswer": "E",
    "options": {
      "A": "Tüm yaprak düğümler aynı seviyededir.",
      "B": "Her düğümün iki çocuğu vardır.",
      "C": "Yalnızca sağa doğru dallanma vardır.",
      "D": "Hiçbir yaprak düğüm yoktur.",
      "E": "Tüm seviyeler tamamen doludur, en alt seviye sola yaslıdır."
    },
    "explanation": "Eksiksiz ikili ağaçta tüm seviyeler tam olarak doludur, en alt seviye ise düğümler sola yaslanacak şekilde doldurulur. “Sağa yaslı olamaz” ifadesiyle de bu desteklenir."
  },
  {
    "id": "3840706",
    "unitNumber": 7,
    "text": "<ol type=\"I\"> <li>Veri türü</li> <li>Ağacın yüksekliği</li> <li>Ağacın şekli</li> <li>Düğüm isimleri</li> </ol> Bir ikili arama ağacında veri ekleme sırasının <strong>farklı</strong> olması, yukarıdakilerden hangilerini <strong>doğrudan etkiler</strong>?",
    "correctAnswer": "B",
    "options": {
      "A": "I ve II",
      "B": "II ve III",
      "C": "III ve IV",
      "D": "I, II ve IV",
      "E": "II, III ve IV"
    },
    "explanation": "Bir <strong>ikili arama ağacı (binary search tree - BST)</strong> oluşturulurken, verilerin eklenme sırası çok önemlidir. Çünkü:<br/><ul> <li> Her yeni düğüm, önceki düğümlere göre konumlandırılır (küçükse sola, büyükse sağa).<br/></li> <li> Dolayısıyla <strong>aynı veriler farklı sıralarda eklendiğinde</strong>, ağacın <strong>şekli</strong> değişir.<br/></li> <li> Bu da doğrudan ağacın <strong>yüksekliğini</strong> etkiler. Bazı sıralamalar dengeli bir yapı oluştururken, bazıları ağacı sarkaç gibi tek tarafa yatık yapabilir.<br/></li> </ul> Veri türü, sıralamadan bağımsızdır. Programlama dili veya uygulamaya göre belirlenir. Düğümlerin isimleri (etiketleri), verinin içeriğine bağlıdır, sıralama bunları değiştirmez.<br/>Buna göre doğru cevap B seçeneğidir."
  },
  {
    "id": "3840723",
    "unitNumber": 7,
    "text": "Aşağıdakilerden hangisi <strong>Kırmızı-Siyah Ağaçlar</strong> için <em>doğru bir özelliktir</em>?",
    "correctAnswer": "E",
    "options": {
      "A": "Her düğüm yalnızca siyah renkte olabilir.",
      "B": "Tüm yaprak düğümler farklı seviyelerde bulunur.",
      "C": "Bir düğümden yaprak düğüme kadar giden her yol aynı sayıda kırmızı düğüm içerir.",
      "D": "Her düğümün yalnızca bir çocuğu olabilir.",
      "E": "Kırmızı-Siyah Ağaçlarda kök düğüm daima siyahtır."
    },
    "explanation": "Kırmızı-Siyah Ağaçlarda denge kurallarından biri, <strong>kök düğümün mutlaka siyah olması gerektiğidir</strong>. Bu kural, ağacın ilk yapısal sabitidir ve ekleme/silme işlemleri sırasında da korunur.<br/><strong>\"Her düğüm yalnızca siyah renkte olabilir\"</strong> - Bu yanlış, çünkü düğümler ya kırmızı ya da siyah olabilir.<br/><strong>\"Tüm yaprak düğümler farklı seviyelerde bulunur\"</strong> - Bu yanlış, çünkü yapraklar (null düğümler) aynı seviyededir.<br/><strong>\"Bir düğümden yaprak düğüme kadar giden her yol aynı sayıda kırmızı düğüm içerir\"</strong> - Bu yanlış, çünkü yolların siyah düğüm sayısı aynıdır; kırmızı sayısı değil.<br/><strong>\"Her düğümün yalnızca bir çocuğu olabilir\"</strong> - Bu yanlış; çoğu ikili ağaç gibi, kırmızı-siyah ağaçlarda düğümlerin iki çocuğu olabiliyor.<br/>Buna göre doğru cevap E seçeneğidir."
  },
  {
    "id": "3840734",
    "unitNumber": 7,
    "text": "Bir BST sınıfında kök düğüm null değilse, Ekle() metodunda veri hangi adımda ağaca yerleştirilir?",
    "correctAnswer": "D",
    "options": {
      "A": "Verinin okunmasından hemen sonra",
      "B": "Rastgele bir konuma",
      "C": "Kök düğüme atandıktan sonra",
      "D": "Boş bir konum bulunana kadar karşılaştırmalar yapıldıktan sonra",
      "E": "Sol çocuk düğüme geçmeden önce"
    },
    "explanation": "Bir <strong>ikili arama ağacı (BST)</strong>'na veri eklerken, ekleme işlemi <strong>karşılaştırmalar yapılarak</strong> uygun bir konumda yapılır. Bu süreç şu şekilde işler:<br/><ol> <li> <strong>Kök düğüm</strong>'den başlanır ve her bir düğüm ile karşılaştırmalar yapılır.<br/></li> <li> <strong>Ekleme işlemi</strong>, yeni verinin mevcut düğüm ile karşılaştırılarak sol ya da sağ alt ağaçlara doğru ilerlenmesiyle gerçekleşir.<br/></li> <li> Bu karşılaştırmalar sonucunda, uygun <strong>boş konum</strong> (sol ya da sağ çocukta) bulunur.<br/></li> <li> Verinin bu boş konumda, belirlenen yere yerleştirilmesi sağlanır.<br/></li> </ol> Bu işlem <strong>ağaçta sıralama</strong>yı koruyarak yapılır. Yani, veriyi yerleştirme işlemi <strong>karşılaştırmalar sonucu</strong> uygun boş düğüm bulunana kadar devam eder.<br/><strong>Verinin okunmasından hemen sonra:</strong> Verinin hemen okunması yeterli değildir; karşılaştırmalar yapılarak doğru konuma yerleştirilmelidir.<br/><strong>Rastgele bir konuma:</strong> Ekleme işlemi rastgele bir konumda yapılmaz, her veri doğru yerinde sıralı bir şekilde yerleştirilir.<br/><strong>Kök düğüme atandıktan sonra:</strong> Kök düğümden başladıktan sonra karşılaştırmalar yapılır, ancak kök düğüme yerleştirmek yeterli değildir.<br/><strong>Sol çocuk düğüme geçmeden önce:</strong> Sol ya da sağ çocuklara geçilmeden önce, karşılaştırmalar sonucunda boş bir düğüm bulunmalıdır.<br/>Ekleme işlemi, verinin doğru konumda yerleştirilmesi için karşılaştırmaların yapılması sonucu uygun boş konumda gerçekleştirilir, bu yüzden doğru cevap <strong>D seçeneğidir.</strong>"
  },
  {
    "id": "3840750",
    "unitNumber": 7,
    "text": "Bir ikili ağacın yüksekliği arttıkça aşağıdaki ifadelerden hangisi doğrudur?",
    "correctAnswer": "D",
    "options": {
      "A": "Arama süresi azalır.",
      "B": "Ağacın dengesi artar.",
      "C": "Düğümlerin derinliği azalır.",
      "D": "Arama süresi uzar.",
      "E": "Yaprak sayısı azalır."
    },
    "explanation": "İkili arama ağaçlarında, bir düğüme ulaşmak için izlenen yolun uzunluğu ağacın yüksekliğiyle doğrudan ilişkilidir.<br/>Yükseklik arttıkça, kökten hedef düğüme kadar geçilecek adım sayısı da artar. Bu da arama işlemlerinin daha uzun sürmesine yol açar.<br/>Özellikle dengesiz ağaçlarda (örneğin sağa eğik yapılar) bu durum verimsizliğe neden olabilir.<br/>Zaman karmaşıklığı da bu nedenle <strong>O(h)</strong> (h = yükseklik) olarak ifade edilir."
  },
  {
    "id": "3840751",
    "unitNumber": 7,
    "text": "Bir ikili arama ağacına ardışık olarak 5, 10, 15, 20, 25 değerleri eklenirse oluşan ağaç yapısı aşağıdakilerden hangisine örnek olur?",
    "correctAnswer": "A",
    "options": {
      "A": "Sağa eğik ikili ağaç",
      "B": "Sola eğik ikili ağaç",
      "C": "Tam ikili ağaç",
      "D": "Dengeli ikili ağaç",
      "E": "Eksiksiz ikili ağaç"
    },
    "explanation": "Bu tür eklemelerde her yeni sayı bir öncekinden büyük olduğu için, <strong>her yeni düğüm sağ çocuk</strong> olarak eklenir.<br/>Bu durum ağacı <strong>sağa eğik çarpık ağaç</strong> (Right Skewed Binary Tree) haline getirir.<br/>Bu yapı dengeli değildir ve neredeyse tek taraflı bir liste gibi davranır."
  },
  {
    "id": "3840752",
    "unitNumber": 7,
    "text": "Bir ikili arama ağacında en küçük değeri bulmak için hangi algoritmik strateji izlenir?",
    "correctAnswer": "A",
    "options": {
      "A": "Sol → Sol → Sol",
      "B": "Sağ → Sağ → Sağ",
      "C": "Kök → Sağ → Sol",
      "D": "Rastgele dallara gidilir",
      "E": "Önce kök yöntemiyle aranır"
    },
    "explanation": "İkili arama ağaçlarında her düğümde <strong>küçük değerler sol çocuklara</strong>, büyük değerler ise sağ çocuklara yerleştirilir.<br/>Bu nedenle, <strong>en küçük değer</strong>, ağacın <strong>en solunda</strong> yer alır.<br/>Bu değeri bulmak için kökten başlanır ve her adımda sol çocuğa gidilerek <strong>Sol → Sol → Sol</strong> şeklinde ilerlenir."
  },
  {
    "id": "3840753",
    "unitNumber": 7,
    "text": "İkili arama ağaçlarında verilerin <strong>artan</strong> sırayla sıralanmasını sağlayan gezinme yöntemi aşağıdakilerden hangisidir?",
    "correctAnswer": "C",
    "options": {
      "A": "Ters İç Kök",
      "B": "Önce Kök",
      "C": "İç Kök",
      "D": "Sonra Kök",
      "E": "Ters Önce Kök"
    },
    "explanation": "<em><strong>İç Kök (Sol-Kök-Sağ)</strong> </em>(infix / inorder) gezinme yöntemiyle, ikili arama ağacında veriler <strong>küçükten büyüğe sıralı</strong> şekilde elde edilir. Bu yöntem sıralama işlemleri için en ideal gezinti yöntemidir.<br/><ul><br/><li><br/>İlk olarak sol alt ağaç,<br/></li><br/><li><br/>sonra kök düğüm,<br/></li><br/><li><br/>en son sağ alt ağaç gezilir.<br/></li><br/></ul><br/><em><strong><br/>Ters İç Kök (Sağ-Kök-Sol); </strong></em>Inorder’ın tam tersi. Önce sağ alt ağaç → sonra kök → sonra sol alt ağaç. Verileri azalan sırada elde etmek istiyorsan kullanılır. Sıralama yapar ama azalan (büyükten küçüğe) şekilde.<em><strong><br/>Önce Kök (Kök-Sol-Sağ); </strong></em>İlk olarak kök düğüm ziyaret edilir. Daha sonra sol ve sağ alt ağaçlar sırasıyla gezilir. Ağacın önce yapısı, sonra içeriği önemlidir. Genellikle ağaç yapısını dosyaya yazmak veya kopyalamak için kullanılır. Verileri artan sırayla sıralamaz. Çünkü kök düğüm, sol çocuklardan önce yazıldığından sıralama özelliği bozulur.<br/><strong>Sonra Kök (Sol-Sağ-Kök);</strong> İlk olarak sol ve sağ alt ağaçlar tamamen gezilir, en son kök düğüm ziyaret edilir. Ağaç yapısını silme gibi işlemlerde kullanılır (önce çocukları temizle, sonra kökü). Verileri sıralı biçimde vermez.<br/><strong>Ters Önce Kök (Kök-Sağ-Sol);</strong> Preorder’ın tersidir. Önce kök → sağ çocuk → sol çocuk. Nadir durumlarda veya bazı özel yazdırma işlemlerinde tercih edilebilir. Artan sıralama sağlamaz."
  },
  {
    "id": "3840754",
    "unitNumber": 7,
    "text": "Aşağıdaki ifadelerden hangisi AVL ağaçları için <strong><em>yanlıştır</em></strong>?",
    "correctAnswer": "C",
    "options": {
      "A": "AVL ağaçları, her düğümde denge faktörünü kontrol eder.",
      "B": "AVL ağaçlarında denge faktörü, sağ ve sol alt ağaçların yükseklik farkıdır.",
      "C": "AVL ağacı, her düğümde tam iki çocuk barındırmalıdır.",
      "D": "Denge faktörü −1, 0 veya 1 olabilir.",
      "E": "AVL ağaçları, arama süresini dengeleyerek iyileştirir."
    },
    "explanation": "AVL ağaçlarında önemli olan her düğümün iki çocuğa sahip olması değil, alt ağaçlarının yükseklik farkının en fazla 1 olmasıdır. Her düğümün iki çocuğu olması zorunlu değildir. Bu, AVL'nin \"dengeli\" olmasını sağlar ama \"tam\" olması gerekmez."
  },
  {
    "id": "3719357",
    "unitNumber": 8,
    "text": "Verilen bir G grafı üzerinde tanımlı di ve dj iki düğüm, kenar kümesinde tanımlı bir kenar ile ilişkilendiriliyorsa bu iki düğüm ------- düğümlerdir?<br/>Yukarıdaki cümlede boş bırakılan yeri aşağıdakilerden hangisi doğru olarak tamamlar?",
    "correctAnswer": "A",
    "options": {
      "A": "Komşu",
      "B": "Yakın",
      "C": "Sıralı",
      "D": "Ardışık",
      "E": "Boşluklu"
    },
    "explanation": "Verilen bir G grafı üzerinde tanımlı di ve dj iki düğüm, kenar kümesinde tanımlı bir kenar ile ilişkilendiriliyorsa bu iki düğüm, <strong>komşu (adjacent)</strong> düğümlerdir."
  },
  {
    "id": "3719361",
    "unitNumber": 8,
    "text": "<strong>Düğümler arasındaki kenarlara yönlendirme atanan graflar aşağıdakilerden hangisidir?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "Yönlü",
      "B": "Yönsüz",
      "C": "Özel",
      "D": "Ağırlıklı",
      "E": "Ağırlıksız"
    },
    "explanation": "Düğümler arasındaki kenarlara yönlendirme atanan graflara yönlü graf adı verilir."
  },
  {
    "id": "3719525",
    "unitNumber": 8,
    "text": "<img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/8b15c9450c510c752ff70ba90467d51e.jpeg\" alt=\"\" width=\"396\" height=\"201\"><br/><strong>Yukarıdaki garf örneğinde düğümleri kişiler olarak düşündüğümüzde aşağıdaki ifadelerden hangisi <u>yanlıştır</u>?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "A kişisi ile E kişisi tanışmaktadır.",
      "B": "A kişisi ile B kişisi tanışmaktadır.",
      "C": "B kişisi ile E kişisi tanışmaktadır.",
      "D": "D kişisi ile E kişisi tanışmaktadır.",
      "E": "C kişisi ile B kişisi tanışmaktadır."
    },
    "explanation": "A kişisi ile E kişisi tanışmamaktadır.<br/>A kişisi ile E kişisi tanışmaMAKTADIR."
  },
  {
    "id": "3719535",
    "unitNumber": 8,
    "text": "<img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/de1319219d9239fa23f18c051930d058.jpeg\" alt=\"\" width=\"384\" height=\"204\"><br/>Yukarıdaki graf örneğinde düğümlerin her biri bir havalimanını temsil etmektedir. Buna göre aşağıdaki ifadelerden hangisi <u>yanlıştır</u>?",
    "correctAnswer": "A",
    "options": {
      "A": "C'den A'ya yalnızca iki aktarma ile gidilebilir.",
      "B": "D'den E'ye direkt uçuş vardır.",
      "C": "C'den B, E ve D'ye direkt uçuş bulunmaktadır.",
      "D": "D'den A'ya gitmek için iki aktarma yapılması gerekmektedir.",
      "E": "B'den A'ya direkt uçuş vardır."
    },
    "explanation": "C'den A'ya gidiş için birden fazla seçenek bulunmaktadır."
  },
  {
    "id": "3719543",
    "unitNumber": 8,
    "text": "<img src=\"https://ets.anadolu.edu.tr/storage/nfs/questions/aa8e966416dd05e485e3b36feb35b946.jpeg\" alt=\"\" width=\"425\" height=\"187\"><br/><strong>Yukarıdaki grafın kenarlar kümesinin matematiksel gösterimi aşağıdaki seçeneklerden hangisinde doğru olarak verilmiştir?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "K = { (a, b), (b, c), (c, d), (e, d), (f, b), (f, e) }",
      "B": "K = { (a, b), (b, f), (c, d), (e, d), (f, b), (f, d) }",
      "C": "K = { (a, b), (b, f), (c, d), (e, g), (f, b), (f, e) }",
      "D": "K = { (a, b), (b, c), (c, d), (e, g), (f, b), (f, e) }",
      "E": "K = { (a, b), (a, c), (c, d), (e, d), (f, d), (f, e) }"
    },
    "explanation": "K = { (a, b), (b, c), (c, d), (e, d), (f, b), (f, e) }"
  },
  {
    "id": "3719551",
    "unitNumber": 8,
    "text": "<strong>Sadece iki düğümün bağlı olup olmamasının önemsendiği graflara ne ad verilir?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "Ağırlıksız graflar",
      "B": "Bitişik graflar",
      "C": "Komşu graflar",
      "D": "Ağırlıklı graflar",
      "E": "Yönsüz graflar"
    },
    "explanation": "Sadece iki düğümün bağlı olup olmaması önemseniyorsa böyle bir graf ağırlıksız olarak adlandırılır.<br/>Aralarında bir kenar bulunan düğümler de birbirlerine bitişik veya komşu düğümler olarak isimlendirilmektedir.<br/>Sadece iki düğümün bağlı olup olmaması önemseniyorsa böyle bir graf ağırlıksız olarak adlandırılır. Aralarında bir kenar bulunan düğümler de birbirlerine bitişik veya komşu düğümler olarak isimlendirilmektedir."
  },
  {
    "id": "3719554",
    "unitNumber": 8,
    "text": "Bir grafiğin veya ağaç veri yapısının tüm düğümlerini aramak için kullanılan yinelemeli (recursive) bir algoritmadır. Geçiş, bir grafiğin tüm düğümlerini ziyaret etmek anlamına gelmektedir.<br/><strong>Yukarıdaki paragrafta sözü edilen algoritma aşağıdakilerden hangisidir?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "Önce Derinlik Araması",
      "B": "Önce Genişlik Araması",
      "C": "Önce Uzunluk Araması",
      "D": "Önce Uzaklık Geçişi",
      "E": "Önce Genişlik Geçişi"
    },
    "explanation": "Önce Derinlik Araması veya Önce Derinlik Geçişi, bir grafiğin veya ağaç veri yapısının tüm düğümlerini aramak için kullanılan yinelemeli (recursive) bir algoritmadır. Geçiş, bir grafiğin tüm düğümlerini ziyaret etmek anlamına gelmektedir."
  },
  {
    "id": "3719556",
    "unitNumber": 8,
    "text": "<strong>BFS Algoritması ile ilgili aşağıdaki ifadelerden hangisi <u>yanlıştır</u>?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "Dar ve uzun ağaçlar oluşturmaktadır.",
      "B": "Minimum yayılan ağaç (Minimum Spanning Tree) gibi alanlarda kullanılmaktadır.",
      "C": "Arama dizinine göre dizin oluşturmak için bir ağda maksimum akışı bulmak amacıyla FordFulkerson algoritmasında kullanılmaktadır.",
      "D": "GPS navigasyonu için kullanılmaktadır.",
      "E": "Yol bulma algoritmaları için kullanılmaktadır."
    },
    "explanation": "BFS Algoritması;<br/>• Yol bulma algoritmaları için kullanılmaktadır.<br/>• GPS navigasyonu için kullanılmaktadır.<br/>• Arama dizinine göre dizin oluşturmak için bir ağda maksimum akışı bulmak amacıyla FordFulkerson algoritmasında kullanılmaktadır.<br/>• Yönsüz bir grafikte döngü algılama ve Minimum yayılan ağaç (Minimum Spanning Tree) gibi alanlarda kullanılmaktadır."
  },
  {
    "id": "3719558",
    "unitNumber": 8,
    "text": "<strong>Aşağıdakilerden hangisi DFS ve BFS algoritmaları arasındaki <u>temel</u> farklardan biridir?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "DFS’de bellek alanı daha verimli bir şekilde kullanılırken BFS’de bellek alanının verimli şekilde<br/>kullanımı göz ardı edilmektedir.",
      "B": "DFS her düğümü hafızada tutarken BFS keşfedilmemiş düğümler üzerinden tek bir yol bilgisini tutabilmek için doğrusal alan kaplamaktadır.",
      "C": "DFS en uygun algoritma iken BFS en uygun değildir.",
      "D": "BFS'de yığın veri yapısı veya özyineleme, DFS'de ise kuyruk veri yapısı kullanılmıştır.",
      "E": "BFS, kenar tabanlı bir algoritma iken DFS, düğüm tabanlı bir algoritmadır."
    },
    "explanation": "DFS, kenar tabanlı bir algoritma iken BFS, düğüm tabanlı bir algoritma olarak tasarlanmıştır.<br/>• DFS yığın veri yapısı veya özyineleme kullanırken BFS’de kuyruk veri yapısı kullanılmıştır.<br/>• DFS’de bellek alanı daha verimli bir şekilde kullanılırken BFS’de bellek alanının verimli şekilde<br/>kullanımı göz ardı edilmektedir.<br/>• BFS en uygun algoritma iken DFS en uygun değildir.<br/>• DFS, dar ve uzun ağaçlar oluştururken BFS, geniş ve kısa bir ağaç oluşturmaktadır.<br/>BFS ve DFS grafik arama algoritmalarının çalışma süreleri birbirine yakındır fakat algoritmaların kullanıldığı alanlar değişmektedir. BFS her düğümü hafızada tutarken DFS keşfedilmemiş düğümler üzerinden<br/>tek bir yol bilgisini tutabilmek için doğrusal alan kaplamaktadır.<br/>BFS ilk sırada en uygun ve verimli hedefi aradığı için DFS’e göre daha uygun bir tercihtir. DFS ise<br/>derin çözümler sunar ve çözüm yoğun olduğunda daha verimli çalışmaktadır.<br/>DFS, kenar tabanlı bir algoritma iken BFS, düğüm tabanlı bir algoritma olarak tasarlanmıştır.<br/>• DFS yığın veri yapısı veya özyineleme kullanırken BFS’de kuyruk veri yapısı kullanılmıştır.<br/>• DFS’de bellek alanı daha verimli bir şekilde kullanılırken BFS’de bellek alanının verimli şekilde<br/>kullanımı göz ardı edilmektedir.<br/>• BFS en uygun algoritma iken DFS en uygun değildir.<br/>• DFS, dar ve uzun ağaçlar oluştururken BFS, geniş ve kısa bir ağaç oluşturmaktadır.<br/>BFS ve DFS grafik arama algoritmalarının çalışma süreleri birbirine yakındır fakat algoritmaların kullanıldığı alanlar değişmektedir. BFS her düğümü hafızada tutarken DFS keşfedilmemiş düğümler üzerinden tek bir yol bilgisini tutabilmek için doğrusal alan kaplamaktadır.<br/>BFS ilk sırada en uygun ve verimli hedefi aradığı için DFS’e göre daha uygun bir tercihtir. DFS ise<br/>derin çözümler sunar ve çözüm yoğun olduğunda daha verimli çalışmaktadır."
  },
  {
    "id": "3719561",
    "unitNumber": 8,
    "text": "<ol type=\"I\"><br/><li>Grafiğin düğümlerinden herhangi birini bir yığına (stack) ekleyerek başlayın.</li><br/><li>Grafın düğümlerinden herhangi birini kuyruğun sonuna ekleyerek başlayın.</li><br/><li>Kuyruğun ilk ögesini alın ve ziyaret edilenler listesine ekleyin.</li><br/><li>Yığının en üst ögesini alın ve ziyaret edilenler listesine ekleyin.</li><br/><li>Bu düğümün bitişik düğümlerinin bir listesini oluşturun. Ziyaret edilenler listesinde olmayanları sıranın en arkasına ekleyin.</li><br/><li>Bu düğümün bitişik düğümlerinin bir listesini oluşturun. Ziyaret edilenler listesinde olmayanları yığının en üstüne ekleyin.</li><br/></ol><br/><strong>Yukarıdaki ifadelerden hangileri DFS algoritmasının çalışma mantığına uygundur?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "I, III ve V",
      "B": "I, IV ve V",
      "C": "I, IV ve VI",
      "D": "I, II, IV ve VI",
      "E": "I, III, IV, V ve VI"
    },
    "explanation": "BFS algoritmasının çalışma mantığı;<br/>1. Grafın düğümlerinden herhangi birini kuyruğun sonuna ekleyerek başlayın.<br/>2. Kuyruğun ilk ögesini alın ve ziyaret edilenler listesine ekleyin.<br/>3. Bu düğümün bitişik düğümlerinin bir listesini oluşturun. Ziyaret edilenler listesinde olmayanları sıranın en arkasına ekleyin.<br/>4. Kuyruk boşalana kadar 2. ve 3. adımları tekrarlamaya devam edin.<br/>DFS algoritmasının çalışma mantığı;<br/>1. Grafiğin düğümlerinden herhangi birini bir yığına (stack) ekleyerek başlayın.<br/>2. Yığının en üst ögesini alın ve ziyaret edilenler listesine ekleyin.<br/>3. Bu düğümün bitişik düğümlerinin bir listesini oluşturun. Ziyaret edilenler listesinde olmayanları<br/>yığının en üstüne ekleyin.<br/>4. Yığın boşalana kadar 2. ve 3. adımları tekrarlamaya devam edin."
  },
  {
    "id": "3842858",
    "unitNumber": 8,
    "text": "I. Graflar düğümler ve kenarlardan oluşan bir kümedir.<br/>II. Düğümler arasındaki ilişkiler ise kenarlarda gösterilmektedir.<br/>III. Graf yapılarında asıl varlıklar kenarlardır.<br/>IV. Düğümler arasındaki bağlantılara yönlendirmeler atanamamaktadır.<br/><strong>Yukarıdakilerden hangileri graf veri modeli için doğrudur?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "I ve II",
      "B": "I ve III",
      "C": "II ve III",
      "D": "II ve IV",
      "E": "III ve IV"
    },
    "explanation": "zorluk derecesi: kolay<br/>III. Graf yapılarında asıl varlıklar <strong>düğümlerdir</strong>.<br/>IV. Düğümler arasındaki bağlantılara yönlendirmeler <strong>atanabilmektedir</strong>."
  },
  {
    "id": "3842861",
    "unitNumber": 8,
    "text": "<strong>Grafikte düğümler arasındaki yönlendirme olmaması durumu hangi graf türünü ifade eder?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "Yönlü graf",
      "B": "Ağırlıklı graf",
      "C": "Yönsüz graf",
      "D": "Çoklu graf",
      "E": "Komple graf"
    },
    "explanation": "zorluk derecesi kolay<br/>Yönsüz graf"
  },
  {
    "id": "3842865",
    "unitNumber": 8,
    "text": "<strong>Aşağıdakilerden hangisi yönlendirilmiş (directed) bir kenarın özelliğidir?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "Başlangıç ve bitiş düğümü yoktur.",
      "B": "Her iki yönde de geçiş yapılabilir.",
      "C": "Tek yönlüdür ve ok ile gösterilir.",
      "D": "Kenarların ağırlığı yoktur.",
      "E": "Her kenarın ikiz bağlantısı vardır"
    },
    "explanation": "zorluk derecesi: orta<br/>Tek yönlüdür ve ok ile gösterilir."
  },
  {
    "id": "3842868",
    "unitNumber": 8,
    "text": "<strong>Bir grafın çapı aşağıdakilerden hangisini ifade eder?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "Grafın en kısa yolunu",
      "B": "Grafın düğüm sayısını",
      "C": "Grafın çevresini",
      "D": "Tüm düğümler arası maksimum mesafeyi",
      "E": "Grafın merkez düğümünü"
    },
    "explanation": "Zorluk derecesi: orta<br/>Tüm düğümler arası maksimum mesafeyi ifade eder."
  },
  {
    "id": "3842874",
    "unitNumber": 8,
    "text": "<strong>DFS (Derinlik Öncelikli Arama) algoritmasında hangi veri yapısı kullanılmaktadır?</strong>",
    "correctAnswer": "B",
    "options": {
      "A": "Kuyruk (Queue)",
      "B": "Yığın (Stack)",
      "C": "Bağlantılı liste (Linked list)",
      "D": "Matris (Matrix)",
      "E": "Hash tablosu"
    },
    "explanation": "zorluk derecesi: zor<br/>Yığın (Stack) kullanılır."
  },
  {
    "id": "3842877",
    "unitNumber": 8,
    "text": "<strong>Aşağıdakilerden hangisi BFS (Önce Genişlik Araması) algoritmasının kullanım alanlarından biri <u>değildir</u>?</strong>",
    "correctAnswer": "E",
    "options": {
      "A": "Yol bulma",
      "B": "GPS navigasyonu",
      "C": "Döngü algılama",
      "D": "Minimum yayılan ağaç bulma",
      "E": "Düğüm derecesi hesaplama"
    },
    "explanation": "zorluk derecesi: orta<br/>Düğüm derecesi hesaplama BFS (Önce Genişlik Araması) algoritmasının kullanım alanlarından biri değildir."
  },
  {
    "id": "3842879",
    "unitNumber": 8,
    "text": "<strong>Grafikte, iki düğüm arasında bir kenar varsa bu düğümlere ne ad verilir?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "Bağlı düğüm",
      "B": "Alt düğüm",
      "C": "Komşu düğüm",
      "D": "Merkezi düğüm",
      "E": "Döngü düğümü"
    },
    "explanation": "zorluk derecesi: orta<br/>Komşu düğüm"
  },
  {
    "id": "3842881",
    "unitNumber": 8,
    "text": "Bir grafın ........., tüm düğümlerden maksimum eksantriklik değerlerinin minimumudur.<br/><strong>Yukarıdaki boşluğa aşağıdakilerden hangisi gelmelidir?</strong>",
    "correctAnswer": "D",
    "options": {
      "A": "Çapı",
      "B": "Merkezi",
      "C": "Derecesi",
      "D": "Yarıçapı",
      "E": "Uzunuğu"
    },
    "explanation": "zorluk derecesi: orta<br/>Bir grafın <strong>yarıçapı</strong>, tüm düğümlerden maksimum eksantriklik değerlerinin minimumudur."
  },
  {
    "id": "3842884",
    "unitNumber": 8,
    "text": "I. DFS, yığın veri yapısı kullanır.<br/>II. BFS, kuyruk veri yapısı kullanır.<br/>III. DFS, düğüm tabanlıdır.<br/>IV. BFS, kenar tabanlıdır.<br/><strong>Yukarıda verilenlerden hangileri doğrudur?</strong>",
    "correctAnswer": "A",
    "options": {
      "A": "I ve II",
      "B": "I ve III",
      "C": "II ve III",
      "D": "III ve IV",
      "E": "I, II ve IV"
    },
    "explanation": "zorluk derecesi: orta<br/>I. DFS, yığın veri yapısı kullanır.<br/>II. BFS, kuyruk veri yapısı kullanır.<br/>öncülleri doğrudur.<br/>III. Yanlış (DFS kenar tabanlıdır, düğüm tabanlı değildir).<br/>IV. Yanlış (BFS düğüm tabanlıdır, kenar tabanlı değildir)."
  },
  {
    "id": "3842885",
    "unitNumber": 8,
    "text": "I. Yönlendirilmiş graflarda ok işareti ile yön belirtilir.<br/>II. Ağırlıksız graflarda kenarlara sayısal değer atanmaz.<br/>III. Komple graflarda tüm düğümler birbirine bağlıdır.<br/>IV. Alt graflar, üst grafın tüm düğüm ve kenarlarını içerir.<br/><strong>Yukarıda verilenlerden hangileri doğrudur?</strong>",
    "correctAnswer": "C",
    "options": {
      "A": "I ve II",
      "B": "I ve III",
      "C": "I, II ve III",
      "D": "II ve IV",
      "E": "III ve IV"
    },
    "explanation": "zorluk derecesi: zor<br/>I. Doğru (Yönlendirilmiş graflarda ok yönü vardır).<br/>II. Doğru (Ağırlıksız graflarda değer atanmaz).<br/>III. Doğru (Komple graflarda tüm düğümler birbirine bağlıdır).<br/>IV. <strong>Yanlış</strong> (Alt graflar, üst grafın alt kümesidir; tümünü içermez)."
  }
]